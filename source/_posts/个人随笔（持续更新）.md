---

title: 个人随笔（持续更新）
date: 2021-05-28 18:07:56
tags: 面经

---

> 该博文是博主本人自己归纳整合的一些面经以及一些零零散散的基础知识点，一方面方便自己以后复习查看，另一方面也是做一个简单的分享。

## JavaScript:



### Jsonp原理：

 Jsonp的全称为：json with padding ，意为填充式的json。

> 1、Ajax直接请求普通文件存在跨域无权限访问的问题，不管是静态页面、动态页面、web服务，只要是跨域请求，一律不准。
>
> 2、不过我们发现，web页面调用js文件则不受跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如<\script>、<\img>、<\iframe>）。
>
> 3、于是可以判断，当前阶段如果想通过纯web端跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。
>
> 4、恰巧我们知道有一种叫做JSON的**纯字符数据格式**可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据。
>
> 5、这样，解决方案就呼之欲出了，web服务端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装进去。
>
> 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来很像ajax，但其实并不一样。
>
> 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，简称**JSONP**。<u>该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名包裹在JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</u>

可以说Jsonp就是为了跨域而生的了。

### Jsonp的实现：

#### 1、远程调用其它服务器上的js文件（跨域成功）

```html
<script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
```

#### 2、远程调用js

在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。

```html
<script type="text/javascript">
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
</script>
<script type="text/javascript" src="http://remoteserver.com/remote.js"></script>

```

remote.js文件代码如下：

```java
localHandler({"result":"我是远程js带来的数据"});
```

运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。

这样一来跨域远程获取数据的目的基本实现了，但是又一个问题出现了，怎么让远程js知道它应该调用的本地函数呢？

#### 3、动态生成js脚本

只要服务端提供的js脚本是动态生成的，这样调用者就可以传一个参数过去告诉服务端，“我想要一段调用xxx函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。

看jsonp.html页面的代码：

```html
<script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
</script>
```

利用编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。

我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。
OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html

```javascript
flightHandler({    "code": "CA1998",    "price": 1780,    "tickets": 5});
```

#### 4、封装代码

jQuery如何实现jsonp调用？

```js
<script type="text/javascript" src=jquery.min.js"></script>
<script type="text/javascript">
   jQuery(document).ready(function(){
   $.ajax({
        type: "get",
        async: false,
        url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",                       dataType: "jsonp",
        jsonp: "callback",
        //传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)             
        jsonpCallback:"flightHandler",
        //自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
        success: function(json){
              alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
                 },             
        error: function(){                 
                    alert('fail');             
               }         
        });    
   }); 
```

jquery在处理jsonp类型的ajax时，自动帮你生成回调函数并把数据取出来供success属性方法来调用。

#### ajax和jsonp的区别：

1、ajax和jsonp这两种技术在调用方式上看起来很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jQuery把jsonp作为ajax的一种形式进行了封装。

2、但ajax和jsonp其实本质上是不同的东西，ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加。



### 原型与原型链：

ES6之前中并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实

![原型与原型链](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/prototype.png)

#### 原型（`prototype`）

- JS所有的函数都有prototype属性，只有函数才有
- 其属性和方法都能被构造函数实例化的对象所共同访问

- `constructor`存在于每个函数的`prototype`属性中，其指向了函数本身

#### 原型链 (`_proto_`）

- JS中的对象会有个`_proto_`属性，指向了创建他的构造函数的`prototype`,而函数比较特殊也有这个属性

- 当JS搜索引擎查找对象中的属性或者方法时，如果在该对象上没有该属性和方法的话，会通过原型链一层一层往上查找
- 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向下搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

```js
var Person = function(name,age) {
   this.name = name;
   this.age = age;
}
Person.prototype.run = function() {
    console.log('running');
}
var me = new Person('小明',10);
// ➀ 每个对象都有一个__proto__属性，并且指向他的prototype原型对象。
console.log(me.__proto__===Person.prototype); // true
// ➁ 每个构造函数都有一个prototype原型对象,prototype原型对象的constructor等于构造函数本身
console.log(Person.prototype.constructor==Person); // true

//原型相关的知识考点一般就是围绕以下：
console.log(Person===Person.prototype.constructor)  // true
console.log(person.__proto__ == Person.prototype) // true
console.log(person.__proto__.constructor == Person) // true
console.log(person.constructor == Person) // true
```

当每创建一个Person构造函数时，在Person构造函数中，为每一个对象都添加了一个run方法，也就是说构造函数每执行一次就会创建一个新的run方法。

一个还好，如果创建了一百个实例，一千个甚至上万个呢，这时候就体现出原型的好处了，我们可以把run方法放到构造函数的prototype上，这时候只需要创建一个，而且每一个实例都可以访问到。

prototype相当于所有实例对象可以访问的一个公共容器，实例对象的`__prorunto__`指向构造函数的`prototype`，从而实现**继承**。

**经典图：**

![原型经典图](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/classic-prototype.jpg)

#### 如何准确判断一个变量是数组类型? 

instanceof 用于判断引用类型属于哪个构造函数的方法 

```js
var arr = [];
arr instanceof Array; //true 
typeof arr; //object typeof 是无法判断是否为数组的
```

instanceof 是用来判断实例的_proto_和构造函数的 prototype 是否指 向一个原型对象，

但是有一个弊端，只要出现在一条原型链上的，都会返回 true（每个函数都有 prototype，每个对象都有一个内部属性__proto__，其指向它的原型对象。原 型对象也是一个对象，所以也有__proto__） 

这个时候要用实例__proto__.constructor 更加严谨 

```js
var arr = [ ]; console.log(arr instanseof Array); //true console.log(arr.__proto__.constructor === Array) //true
console.log( arr instanceof Array ) 
console.log( arr.construct == Array) 
console.log( Array.isArray( arr ))
```



#### new 操作符在创建实例的时候经历了哪几个阶段 

new 创建了一个对象，共经历了 4 个阶段： 

1. 创建一个空对象 
2. 设置原型链 
3. 让实例化对象中的 this 指向对象，并执行函数体 
4. 判断实例化对象的返回值类型



#### 类型的判断方法

**1、typeof**

>未定义、未初始化：返回 `"undefined"`
>
>布尔值：返回 `"boolean"`
>
>字符串：返回 `"string"`
>
>数值(包括NAN)：返回 `"number"`
>
>对象、null：返回 `"object"`， null 表示空对象指针
>
>函数：返回 `"function"`
>
>**注意**：`typeof`可以判断基本类型，无法判断对象的类型或者null

**2、instanceof**

>如果变量是引用类型，可以使用instanceof判断，检测基本类型时，会返回false。
>
>原理：判断变量的原型链上是否有构造函数的prototype属性
>
>**注意：空对象{}的判断问题**        //true

**3、Object.prototype.toString**

> 所有的数据类型都可以使用此方法进行检测，且非常精准。如：
>
> Object.prototype.toString.call(obj) === '[object Object]'





#### 了解更多相关：

ES5继承实现、ES6类实现、typeof&&instanceof原理：https://juejin.cn/post/6844903984335945736



### 继承



### This:

**1. 默认绑定与隐式绑定**

让我们看看下面这个例子：

```js
function foo() { 
    console.log(this.bar); 
} 
var bar = "bar1"; 
var o2 = {bar: "bar2", foo: foo}; 
var o3 = {bar: "bar3", foo: foo}; 
foo();            // "bar1" – 默认绑定
o2.foo();          // "bar2" – 隐式绑定
o3.foo();          // "bar3" – 隐式绑定
```

foo()这种调用方法，就是默认绑定。如果在非严格模式下，this就是全局对象，浏览器当中就是window。而如果在严格模式（use strict）下，this就会是undefined。

之所以这是默认绑定，因为foo的调用不属于任何人，前面没有任何限定条件。这是最简单的绑定。

o2.foo()和o3.foo()这两种调用方法，都是隐式绑定。Foo是作为o2和o3的方法而调用的，那么谁调用foo，this就指向谁。在上面的例子中，o2.foo()中的this指向o2，因此this.bar就是o2当中的bar: “bar2”；同理，o3.foo()打印出来的就是o3中的”bar3”。

**2. 显式绑定**

```js
function foo() { 
console.log(this.bar); 
} 
var bar = "bar1"; 
var obj = {bar: "bar2"}; 

foo();          // "bar1"   默认绑定
foo.call(obj);     // "bar2"  显式绑定，使用obj作为"this" 
```

如果foo是通过call、apply或者bind调用的，那么这种调用就是显式绑定。这种绑定中,this的指向就是这三个函数中传递的第一个参数。

**3. 关键字new绑定**

```js
function foo() { 
    this.baz = "baz"; 
    console.log(this.bar + " " + baz); 
} 
var bar = "bar"; 
var baz = new foo(); 
```

如果把new这个关键字放在一个函数调用的前面，JS编译器会做这四件事情：

>1. 创建一个新的空的对象
>2. 把这个对象链接到原型对象上
>3. 这个对象被绑定为this
>4. 如果这个函数不返回任何东西，那么就会默认return this

上面的例子，最终会输出undefined undefined。这是因为baz这个变量并没有bar这个属性，而baz此时只被定义，没有被赋值，因此baz也是undefined。

**4. 箭头函数**

箭头函数会无视以上所有的规则，this的值就是函数创建时候所在的lexical scope中的this，而和调用方式无关。可以对比下面两个例子：

```js
function Person(){
  this.age = 0;
  setTimeout(function () {
    console.log(this.age);     // 输出undefined
  }, 1000);
}
var p = new Person();
function Person(){
  this.age = 10;
  setTimeout(()=> {
    console.log(this.age);     // 输出10
  }, 1000);
}
var p = new Person();
```

在上面没有使用箭头函数的例子当中，setTimeout内部的函数是被global调用的，而global没有age这个属性，因此输出undefined。

第二个例子使用了箭头函数，this就会使用lexical scope中的this，就是Person，因此输出10。

```js
var name = 'Nicolas';
function Person(){
    this.name = 'Smiley';
    this.sayName=function(){
        console.log(this); 
        console.log(this.name); 
    };
    setTimeout(this.sayName, 0);     *// 第二次输出*
}
var person = new Person();
person.sayName();   *// 第一次输出*
```

第一次输出的是Person, Smiley。第二次输出的结果是window，Nicolas。尽管setTimeout是在构造函数中定义的，但是调用的时候，是在window中调用。

```js
function Person() {
  this.name = "Smiley";
  this.sayName = function(){
    console.log(this);
    console.log(this.name); 
  };
}
 
let person = new Person();
let sayNameCopy = person.sayName;
sayNameCopy();
```

答案是window和undefined。因为，这个时候符合默认绑定的规则。

![this指向](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/this.jpg)

**5. 绑定优先级**

如果多重绑定规格都适用，那么绑定规则的优先级顺序是这样的：

>1. 箭头函数
>2. 关键字new调
>3. 显式绑定
>4. 隐式绑定
>5. 默认绑定

箭头函数优先级最高，会无视2-5绑定规则。而默认绑定优先级最低，只有其他绑定都不使用的时候，才会使用默认绑定。

### Promise：

> Promise是异步编程的一种解决方案，它比传统的解决方案--回调函数和事件--更合理且更加强大，它最早是由社区提出并实现，后面ES6将其写进了语言标准，统一了用法，也提供了Promise。

#### 用法：

##### 1.创建Promise实例：

```jsx
const promise = new Promise(function(resolve, reject) {
    if (/*异步操作成功*/) {
        resolve(value)
    } else {
        reject(error)
    }
})
```

- Promise构造函数接受一个函数作为参数，该函数接受两个参数，分别是resolve和reject，它们是两个函数，是由javascript引擎提供，不用自己部署。
- resolve作用是将Promise对象状态由‘未完成’变为‘成功’，也就是Pending -> Fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去，而rejected函数则是将Promise对象状态由‘未完成’变为‘失败’，也就是Pending -> Rejected，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。
- Promise 可以分为四个状态：
  -  Pending：初始状态，异步操作仍在进行中。
  -  Fulfilled：操作成功，它调用`.then`回调，例如`.then(onSuccess)`。
  -  Rejected: 操作失败，它调用`.catch`或`.then`的第二个参数（如果有）。 例如`.catch(onError)`或`.then(..., onError)`。
  -  **Settled**：这是 promise 的最终状态。promise 已经死亡了，没有别的办法可以解决或拒绝了。 `.finally`方法被调用。
- **一旦状态改变就不会再发生变化**（两种状态改变：成功或失败）

##### 2.Promise的方法：

> then方法: 这个方法是定义在原型对象Promise.prototype上的，它的作用是为Promise实例添加状态改变时的回调函数。它返回的是一个新的Promise实例，注意，不是原来的那个Promise实例，因此可以采用链式写法，即then方法后面再调用一个then方法。
> Promise实例生成后，可用then方法分别指定两种状态回调函数，then方法可用接受两个回调函数作为参数：
> （1）  Promise对象状态改为Resolved时调用（必须）
> （2） Promise对象状态改为Rejected时调用（可选）
> （3） 基本用法：

```jsx
function sleep(ms) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve, ms);
    })
}
sleep(500).then( ()=> console.log("finished"));
```

这段代码定义了一个函数sleep，调用后，等待了指定参数（500）毫秒后执行then中的函数。值得注意的是，Promise新建后就会立即执行。



> catch方法: 这个方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
>
> 我们可以使用`then`函数的第二个参数来处理错误。 但是，请注意，`catch`将不再执行。

```jsx
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```

上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数，如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误，另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。

如果Promise状态已经变成resolved，再抛出错误是无效的。Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数）就使用catch方法



> finally方法: `finally`方法只在 Promise 状态是 `settled` 时才会调用。
>
> 如果你希望一段代码即使出现错误始终都需要执行，那么可以在`.catch`之后使用`.then`。
>
> 或者可以使用`.finally`关键字:

```js
Promise.resolve()
  .then(a)
  .then(b)
  .then(c)
  .then(d)
  .catch(console.error)
  .finally(() => console.log('always called'));
```



##### 3 Promise 类方法：

我们也可以直接使用 `Promise` 对象中四种静态方法。

- Promise.all
- Promise.reject
- Promise.resolve
- Promise.race

> Promise.resolve 和 Promise.reject这两个是帮助函数，可以让 Promise 立即解决或拒绝。可以传递一个参数，作为下次 `.then` 的接收：



> 使用 `Promise.all` 并行执行多个 Promise ,通常Promise 是一个接一个地依次执行的，但是你也可以并行使用它们。假设是从两个不同的api中轮询数据。如果它们不相关，我们可以使用`Promise.all()`同时触发这两个请求。

```js
const a = () => new Promise((resolve) => setTimeout(() => resolve('a'), 2000));
const b = () => new Promise((resolve) => setTimeout(() => resolve('b'), 1000));
const c = () => new Promise((resolve) => setTimeout(() => resolve('c'), 1000));
const d = () => new Promise((resolve) => setTimeout(() => resolve('d'), 1000));

console.time('promise.all');
Promise.all([a(), b(), c(), d()])
  .then(results => console.log(`Done! ${results}`))
  .catch(console.error)
  .finally(() => console.timeEnd('promise.all'));
```

解决这些 Promise 要花多长时间？ 5秒？ 1秒？ 还是2秒？



> Promise.race(iterable) 方法: 返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝

```js
const a = () => new Promise((resolve) => setTimeout(() => resolve('a'), 2000));
const b = () => new Promise((resolve) => setTimeout(() => resolve('b'), 1000));
const c = () => new Promise((resolve) => setTimeout(() => resolve('c'), 1000));
const d = () => new Promise((resolve) => setTimeout(() => resolve('d'), 1000));

console.time('promise.race');
Promise.race([a(), b(), c(), d()])
  .then(results => console.log(`Done! ${results}`))
  .catch(console.error)
  .finally(() => console.timeEnd('promise.race'));
```

输出 `b`。使用 `Promise.race`，最先执行完成就会是最后的返回结果。

在某些情况下，它可以派上用场，比如计时请求或批量处理请求数组。

```js
Promise.race([
fetch('http://slowwly.robertomurray.co.uk/delay/3000/url/https://api.jsonbin.io/b/5d1fb4dd138da811182c69af'),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error('request timeout')), 1000))
])
.then(console.log)
.catch(console.error);
```



#### 关于Promise 的问题：

**1.async await：**

```js
let a;
const b = new Promise((resolve, reject) => {
  console.log('p1');
  resolve();
}).then(() => {
  console.log('p2');
}).then(() => {
  console.log('p3');
}).then(() => {
  console.log('p4');
});

a = new Promise(async (resolve, reject) => {
  console.log(a);
  await b;
  console.log(a);
  console.log('after1');
  await a
  resolve(true);
  console.log('after2');
});

console.log('end');

//p1 -> undefined -> end -> p2 -> p3 -> p4 -> p{pending} -> after1
```

> 第一个输出 p1，是因为 Promise 里的方法立即执行。接着调用 resolve，只不过 then 里的方法等下一个周期
>
> 第二个输出 undefined，是因为立即执行执行 a 内部的方法，先 console.log(a)，但此时的 a 还没赋值给左边的变量，所以只能是 undefined。然后 await b 就得等下一个周期执行了。
>
> 第三个输出 end，自然不意外。
>
> 接着输出 p2，p3，p4，是因为 await b 等待他执行完了，才轮到 a 内部继续执行。
>
> 输出 Promise { pending }，事件都进入了循环，a 肯定已经被赋值成了 Promise 对象。所以第二遍 console.log(a)，自然就输出这个了。
>
> 输出 after1 不奇怪。
>
> await a 时，a 是必须等待 Promise 的状态从 pending 到 fullfilled 才会继续往下执行，可 a 的状态是一直得不到更改的，所以无法执行下面的逻辑。只要在 await a 上面加一行 resolve() 就能让后面的 after 2 得到输出



**2..如何限制并行 Promise？**

要做到这一点，我们需要以某种方式限制`Promise.all`。假设你有许多并发请求要执行。 如果使用 `Promise.all` 是不好的（特别是在API受到速率限制时）。 因此，我们需要一个方法来限制 Promise 个数， 我们称其为`promiseAllThrottled`。

```js
// simulate 10 async tasks that takes 5 seconds to complete.
const requests = Array(10)
  .fill()
  .map((_, i) => () => new Promise((resolve => setTimeout(() => { console.log(`exec'ing task #${i}`), resolve(`task #${i}`); }, 5000))));

promiseAllThrottled(requests, { concurrency: 3 })
  .then(console.log)
  .catch(error => console.error('Oops something went wrong', error));
```

以上代码将并发限制为并行执行的`3`个任务。

实现`promiseAllThrottled `一种方法是使用`Promise.race`来限制给定时间的活动任务数量。

```js
/**
 * Similar to Promise.all but a concurrency limit
 *
 * @param {Array} iterable Array of functions that returns a promise
 * @param {Object} concurrency max number of parallel promises running
 */
function promiseAllThrottled(iterable, { concurrency = 3 } = {}) {
  const promises = [];

  function enqueue(current = 0, queue = []) {
    // return if done
    if (current === iterable.length) { return Promise.resolve(); }
    // take one promise from collection
    const promise = iterable[current];
    const activatedPromise = promise();
    // add promise to the final result array
    promises.push(activatedPromise);
    // add current activated promise to queue and remove it when done
    const autoRemovePromise = activatedPromise.then(() => {
      // remove promise from the queue when done
      return queue.splice(queue.indexOf(autoRemovePromise), 1);
    });
    // add promise to the queue
    queue.push(autoRemovePromise);

    // if queue length >= concurrency, wait for one promise to finish before adding more.
    const readyForMore = queue.length < concurrency ? Promise.resolve() : Promise.race(queue);
    return readyForMore.then(() => enqueue(current + 1, queue));
  }

  return enqueue()
    .then(() => Promise.all(promises));
}
```

`promiseAllThrottled`一对一地处理 Promises 。 它执行`Promises`并将其添加到队列中。 如果队列小于并发限制，它将继续添加到队列中。 达到限制后，我们使用`Promise.race`等待一个承诺完成，因此可以将其替换为新的承诺。 这里的技巧是，promise 自动完成后会自动从队列中删除。 另外，**我们使用 `race` 来检测promise 何时完成，并添加新的 promise 。**



3.Promise 解决的痛点是什么？

1）回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象，是为解决异步操作函数里的嵌套回调（callback hell）问题，代码臃肿，可读性差，只能在回调里处理异常

2）<u>promise可以支持多个并发的请求，获取并发请求中的数据</u>

3）<u>promise可以解决可读性的问题，异步的嵌套带来的可读性的问题，它是由异步的运行机制引起的，这样的代码读起来会非常吃力</u>

4）promise可以解决信任问题，对于回调过早、回调过晚或没有调用和回调次数太少或太多，由于promise只能决议一次，决议值只能有一个，决议之后无法改变，任何then中的回调也只会被调用一次，所以这就保证了Promise可以解决信任问题



4.Promise 在事件循环中的执行过程是怎样的？

1）事件循环

> 从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。由于主线程不断的重复获得消息、执行消息、再取消息、再执行

2）promise的事件循环

> Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环

### 事件模型：

事件模型可以分为三种：

**原始事件模型（DOM0级）**

事件绑定监听函数比较简单, 有两种方式：

1. HTML代码中直接绑定

```html
<input type="button" onclick="fun()">
```



2. 通过JS代码绑定

```js
var btn = document.getElementById('.btn');
btn.onclick = fun;
```



DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行。**只支持冒泡，不支持捕获**。同一个类型的事件只能绑定一次，当希望为同一个元素绑定多个同类型事件的时候是不被允许的，后绑定的事件会覆盖之前的事件。

删除 DOM0 级事件处理程序只要将对应事件属性置为null即可


**标准事件模型（DOM2级）**

在该事件模型中，一次事件共有三个过程:

> 事件捕获阶段：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行
>
> 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数
>
> 事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



1. 事件绑定监听函数的方式如下:

```js
addEventListener(eventType, handler, useCapture)
```



2. 事件移除监听函数的方式如下:

```js
removeEventListener(eventType, handler, useCapture)
```

可以在一个`DOM`元素上绑定多个事件处理器，各自并不会冲突



**IE事件模型（基本不用）**

IE事件模型共有两个过程:

> 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。
>
> 事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



事件绑定监听函数的方式如下:

```js
attachEvent(eventType, handler)
```


事件移除监听函数的方式如下:

```js
detachEvent(eventType, handler)
```



### 事件循环：

#### 浏览器中的事件循环：

> JavaScript 是单线程的语言，所谓单线程无非就是同步队列和异步队列，js代码是自上向下执行的，在主线程中立即执行的就是同步任务，比如简单的逻辑操作及函数，而异步任务不会立马立马执行，会挪步放到到异步队列中，而不同的异步操作添加到任务队列的时机也不同，比如onclick（事件）, setTimeout（计时器）, ajax ，promise处理的方式都不同，总的说就是**等待主线程中任务全部完成后，再回来把异步队列中任务放到主程序中运行，这样反复的循环，就是事件循环。**
>
> 这些异步操作是由浏览器内核来执行的,浏览器内核上包含 3 种 webAPI,分别是 DOM Binding(DOM绑定)、network(网络请求)、timer(定时器)模块

按照这种分类方式:JS 的执行机制是

> 首先判断 js 代码是同步还是异步,不停的检查调用栈中是否有任务需要执行,如果没有,就检查任务队列,从中弹出一个任务,放入栈中,如此往复循环,要是同步就进入主进程,异步就进入事件表
>
> 异步任务在事件表中注册函数,当满足触发条件后,被推入事件队列
>
> 同步任务进入主线程后一直执行,直到主线程空闲时,才会去事件队列中查看是否有可执行的异步任务,如果有就推入主进程中
>
> 以上三步循环执行,这就是事件循环(event loop),它是连接任务队列和控制调用栈的

在一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务）。

**macro-task大概包括：**

> script(整体代码)、setTimeout、setInterval、setImmediate、I/O、UI render

**micro-task大概包括:**

> process.nextTick、Promise、Async/Await(实际就是promise)、MutationObserver(html5新特性)

![img](https://pic4.zhimg.com/v2-0d7af3f483aa991d41dd1f3ba7bac36f_b.webp)

总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

```js
console.log('script start')

async function async1() {
await async2()
console.log('async1 end')
}
async function async2() {
console.log('async2 end')
}
async1()

setTimeout(function() {
console.log('setTimeout')
}, 0)

new Promise(resolve => {
console.log('Promise')
resolve()
})
.then(function() {
console.log('promise1')
})
.then(function() {
console.log('promise2')
})

console.log('script end')
 // 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动
// script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout
```

代码分析：

> 执行代码，输出script start。
>
> 执行async1(),会调用async2(),然后输出async2 end,<u>此时将会保留async1函数的上下文，然后跳出async1函数。</u>
>
> 遇到setTimeout，产生一个宏任务
>
> 执行Promise，输出Promise。遇到then，产生第一个微任务
>
> 继续执行代码，输出script end
>
> 代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，该微任务遇到then，产生一个新的微任务
>
> 执行产生的微任务，输出promise2,当前微任务队列执行完毕。执行权回到async1
>
> 执行await,实际上会产生一个promise返回，即
>
> let promise_ = new Promise((resolve,reject){ resolve(undefined)})
> 执行完成，执行await后面的语句，输出async1 end
>
> 最后，执行下一个宏任务，即执行setTimeout，输出setTimeout
>
> 注意
> **新版的chrome浏览器中不是如上打印的，因为chrome优化了,await变得更快了,输出为:**
>
> ```js
> // script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout
> ```



如果await后面跟的是一个异步函数的调用，比如上面的代码，将代码改成这样：

```js
console.log('script start')

async function async1() {
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2 end')
    return Promise.resolve().then(()=>{
        console.log('async2 end1')
    })
}
async1()

setTimeout(function() {
    console.log('setTimeout')
}, 0)

new Promise(resolve => {
    console.log('Promise')
    resolve()
})
.then(function() {
    console.log('promise1')
})
.then(function() {
    console.log('promise2')
})

console.log('script end')
输出为：

// script start => async2 end => Promise => script end => async2 end1 => promise1 => promise2 => async1 end => setTimeout
```

此时执行完awit并不先把await后面的代码注册到微任务队列中去，而是执行完await之后，直接跳出async1函数，执行其他代码。然后遇到promise的时候，把promise.then注册为微任务。其他代码执行完毕后，需要回到async1函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中，**注意此时微任务队列中是有之前注册的微任务的**。所以这种情况会先执行async1函数之外的微任务(promise1,promise2)，然后才执行async1内注册的微任务(async1 end). 可以理解为，这种情况下，await 后面的代码会在本轮循环的最后被执行。



#### node 中的事件循环：

```js
┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

1. node 的事件循环的阶段顺序为：

   > 输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...
   > 每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。

2. 阶段概述：

  > 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。
  >
  > I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。
  >
  > 闲置阶段(idle, prepare)：仅系统内部使用。
  >
  > 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
  >
  > 检查阶段(check)：setImmediate() 回调函数在这里执行
  >
  > 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。

日常开发中的绝大部分异步任务都是在 poll、check、timers 这3个阶段处理的。



**timers:**

timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。



**poll:**

poll 是一个至关重要的阶段，poll 阶段的执行逻辑流程图如下：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X2pwZy8yd1Y3TGljTDc2Mll4VmlhR3NFbmhSOUtpYmJHNnlRcXBjRWo0VlBGcE9PdnpOYW51S1NnMURvNWVKQlV2SVNvQnNpYVNPN3hTM2liZWpkSGJ6NDhseGRXN3hnLzY0MA?x-oss-process=image/format,png)

> 如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。
>
> 如果没有定时器, 会去看回调函数队列。
>
> 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
>
> 如果 poll 队列为空时，会有两件事发生
>
> 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
>
> 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。



**check:**

check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。



**process.nextTick:**

process.nextTick 是一个独立于 eventLoop 的任务队列。

在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。





#### node 版本差异说明:

<u>*总的变化一句话来说就是，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就会立刻执行对应的微任务队列。*</u>

**timers 阶段的执行时机变化:**

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
```


如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=>promise1=>timer2=>promise2

如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.

如果是第二个定时器还未在完成队列中，最后的结果为timer1=>promise1=>timer2=>promise2

如果是第二个定时器已经在完成队列中，则最后的结果为timer1=>timer2=>promise1=>promise2



**check 阶段的执行时机变化：**

```js
setImmediate(() => console.log('immediate1'));
setImmediate(() => {
    console.log('immediate2')
    Promise.resolve().then(() => console.log('promise resolve'))js
});
setImmediate(() => console.log('immediate3'));
setImmediate(() => console.log('immediate4'));
```


如果是 node11 后的版本，会输出immediate1=>immediate2=>promise resolve=>immediate3=>immediate4

如果是 node11 前的版本，会输出immediate1=>immediate2=>immediate3=>immediate4=>promise resolve



**nextTick 队列的执行时机变化：**

```js
setImmediate(() => console.log('timeout1'));
setImmediate(() => {
    console.log('timeout2')
    process.nextTick(() => console.log('next tick'))
});
setImmediate(() => console.log('timeout3'));
setImmediate(() => console.log('timeout4'));
```


如果是 node11 后的版本，会输出timeout1=>timeout2=>next tick=>timeout3=>timeout4

如果是 node11 前的版本，会输出timeout1=>timeout2=>timeout3=>timeout4=>next tick



#### node 和 浏览器 eventLoop的主要区别：

两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。



#### 了解更多：

[彻底吃透 JavaScript 执行机制](https://juejin.cn/post/6844903955286196237)



### 闭包：

官方的各种定义引用:

> MDN: 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

> 红宝书: 闭包是指有权访问另外一个函数作用域中的变量的函数。

> 现代JavaScript教程: 闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。

**简单来说就是我在写代码时候我们决定了这些变量的访问权限也就是[词法作用域](https://juejin.im/post/6889538437783748621)。然而我们可以用些手段(闭包)如`return` 一个函数。这样即使这个function在当前词法作用域外执行，也能访问原来定义时词法作用域内的变量，（间接地访问了这些变量）。**

```javascript
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz(); // 2       这就是闭包的效果。
```

按照词法作用域来说：`baz`的词法作用域是全局的，外部不能访问foo内部作用域的变量 `a`，但是 `a`确实被正常打印了。而函数 `bar()` 的词法作用域能够访问 `foo()` 的内部作用域。将 `bar` 所引用的函数对象本身当作返回值。 在 `foo()` 执行后， 其返回值(也就是内部的 `bar()`函数) 赋值给变量 `baz` 并调用 `baz()`， 实际上只是通过不同的标识符引用调用了内部的函数 `bar()`。bar() 显然可以被正常执行。

但是在这个例子中，它在自己**定义的词法作用域以外** 的地方执行了。

在 `foo()` 执行后，通常会期待 `foo()` 的整个内部作用域都被销毁，因为我们知道引擎有**垃圾回收机制**用来释放不再使用的内存空间。由于看上去 `foo()` 的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域?原来是 `bar()` 本身在使用。拜 `bar()` 所声明的位置所赐，它拥有涵盖 `foo()` 内部作用域的闭包，使得该作用域能够一直存活，以供 `bar()` 在之后任何时间进行引用。bar() 依然持有对该作用域的引用。

这样做的话一是**可以读取函数内部的变量**，二是**可以让这些变量的值始终保存在内存中**。

**无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。**



```javascript
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
```

正常情况下， 这段代码预期是分别输出数字 1~5， 每秒一次， 每次一个。

但实际上， 这段代码在运行时会以每秒一次的频率输出五次 6。

我们可以利用闭包来解决这个问题。 首先这种IIFE(立即执行函数表达式) 是一個定义完馬上就執行的 JavaScript function，可以创建闭包。

```javascript
for (var i = 1; i <= 5; i++) {
    (function(j) {
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })(i);
}
```

不熟IIFE用`let`也成，本质上这是将一个块转换成一个可以被关闭的作用域。也就是块级作用域。

总的来说闭包就是：

> 当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量,其特点便是：
>
> 1、让外部访问函数内部变量成为可能
>
> 2、局部变量会常驻在内存中
>
> 3、可以避免使用全局变量，防止全局变量污染
>
> 4、会造成内存泄漏（有一块内存空间被长期占用，而不被释放）



### [JS模块化](https://blog.csdn.net/qq_27575925/article/details/113758050)开发规范：

**CommonJS**

- 一个文件一个模块；
- 使用 exports.xx = ... 或者 module.exports ={} 暴露模块；
- 使用 require() 方法引入一个模块；
- require()是同步执行的；

```js
// a.js
let fn=function(msg){
  console.log(msg);
}
exports.outMsg=fn;

//b.js
const a=require('./a.js');
a.outMsg('hello Commonjs'); // hello Commonjs
```

> CommonJS 在NodeJS 环境用，不适用于浏览器；
> 一个文件一个模块；如果有多个导出，则去最后一个导出；

**AMD**

全称 Asynchronous module definition（异步模块定义）

- 使用 define(...) 定义一个模块；
- 使用require(...) 加载一个模块；
- 依赖前置，提前执行；

RequireJS 是AMD 的一种实现

```js
// 模块的定义
/**
*@param id 模块名称，如果为空，模块的名字默认为模块加载器请求的制定脚本名
*@param dependencies 模块依赖
*@param factory 工厂函数，模块初始化执行函数或对象
*/
define(id,dependencies,factory)

// 模块的使用，使用 require 加载模块
require（[module],callback）;
```

**CMD**

全称 Common Module Definition（通用模块定义）

- 一个文件为一个模块
- 使用 define(...) 定义一个模块 （和AMD相似）
- 使用require(...) 加载一个模块（和AMD 相似）

SeaJS 是CMD 的一种实现

```js
// CMD 
define(function(require,exports,module){
  var a=require('./a');
  a.sayHello();
  var b=require('./b');// 依赖就近书写；
  b.sayHello();
  //...
});
```

> CMD和AMD 的最显著的区别 AMD 是提前执行，CMD 是延迟执行，依赖就近；
> AMD： 执行过程中会将所有的依赖模块前置执行，也就是自己的代码逻辑开始前全部执行；
> CMD ：如果require 但整个逻辑未使用这个依赖 或者为执行到逻辑使用它的地方前，不会执行。

**UMD**

全称 Universal Module Definition（万能模块定义），从名字就可以看出 UMD 做的是大一统的工作。Webpack 打包代码就有 UMD 这个选项。

这个万能模块，可以在服务端使用，也可以在浏览器端使用；

它主要做了三件事：

- 判断是否支持AMD
- 判断是否支持CommonJS
- 如果都不支持，使用全局变量

```js
(function (root, factory) {
    // 对应上述的三个步骤
    if (typeof define === 'function' && define.amd) {
        // 1.判断是否支持 AMD
        // 如果 define 这个方法是被定义 并且 define 这个方法是 AMD 的规范，那就把 factory 这个模块实体用 define 方法以 AMD 的规范 定义
        define([], factory); // [] 是依赖，factory 是模块实体
    } else if (typeof exports === 'object') {
        // 2. 判断是否支持 CommonJS
        // 如果 exports 是等于一个对象，则表明是在 Node 环境中运行，则支持 CommonJS，那就用 module.exports 暴露整个模块实体
        module.exports = factory();
    } else {
        // 3. 如果都不支持，使用全局变量
        // Browser globals (root 即是 window)
        root.returnExports = factory();
  }
}(this, function () {
    // Module Defination
    var sum = function(x, y){
        return x + y;
    }
    var sub = function(x, y){
        return x - y;
    }
    var math = {
        findSum: function(a, b){
            return sum(a,b);
        },
        findSub: function(a, b){
            return sub(a, b);
        }
    }
    return math;
}));
```

**ES Module (ES6 模块)**

全称 ECMAScript Module

- 使用 import 导入模块；
- 使用 export 导出模块；

```js
// 导出模块
export var a='123'; //导出变量
export function fn(){}; // 导出函数
export default {name:'p',age:18} // 导出对象； export 不能直接导出对象必须加上default；
export class Myclass{} // 导出类；
```

#### ES6 模块和Common js 模块的差异：

1、CommonJS 输出的是一个值的拷贝；ES6 模块输出的是值的引用；

2、CommonJS 模块是运行时加载；ES6模块是编译时输出接口；

由于ES6 模块是编译时输出接口，所以可以做到 tree shaking；

#### **import 和 require 导入的区别**

import 的ES6 标准模块：是编译时调用，所以必须放在文件开头，是解构过程。

require 是 AMD规范引入方式：是运行时调用，所以require理论上可以运用在代码的任何地方，是赋值过程。

其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量。



## CSS

#### CSS 优先规则

**选择器:**

ID 选择器 (#ID)  Class 选择器 (.class 名)  标签选择器 (标签)  通配符 (*)

相邻选择器 (div+p)   子选择器 (div>p)  后代选择器 (div p)   多个选择器 (div,p,a,ul)

伪类选择器 (a:hover) 

**伪类选择器和伪元素的区别:** 

伪类用于向某些选择器添加特殊效果 (单冒号)

伪元素用于将某个特殊的东西添加到某些元素的前后 (双冒号)

> 优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器

**::after/:after 与::before/:before 的区别** 

:before 在元素之前添加效果/:after 是在元素之后添加效果;

:after/:before 是 CSS2 提出的,兼容 IE8;

::after/::before 是 CSS3 为了区分伪类和伪元素的做出的差 别,为了避免兼容性问题,习惯性的还是写:after/:before; 

可继承样式: font-size/fon-family/color 

不可继承样式:width/height/margin/padding/border

#### CSS定义的权重

> 1就近原则,后加样式优于前面的样式 
>
> 2内嵌样式>内联样式>外联样式 
>
> 3 !Important 大于一切样式

```css
// 以下是权重的规则：继承的样式没有权值,标签类型选择器和伪元素 :div/p的权重为1，class/伪类/属性选择器的权重为10，id的权重为100，内联样式:style=””为1000,以下/// 例子是演示各种定义的权重值：

/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
}

// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现
```

#### CSS 单位 px、em、rem、rpx、vh、vw 的解释比较

>1. px也就是像素，第一印象它是绝对长度，是定死的，所以想要响应式布局和自适应布局不要用它。但其实”绝对“，”定死“这些并不准确，它的大小也是会随着屏幕变化的。
>2. rem使用更方便且用途更普遍，所以我们先来看rem。非常简单，设定根元素<html>的font-size属性，默认为16px，那么1rem = 16px。设置为20px，那么1rem = 20px。为了简化计算，我们想令1rem = 10px，就设定根元素font-size为10px或者62.5%（16*62.5%=10）。用 rem 有什么好处？可以实现响应式布局了！响应式布局指的是元素大小能根据屏幕大小随时变化，因为 rem 布局里所有大小跟着根元素变化，所以只要在屏幕大小变化的时候改变根元素font-size就行了。
>3. rpx是微信小程序为了解决自适应屏幕尺寸设计的单位，它规定任何屏幕的宽都是750rpx。vw是css3新出的单位，规定任何屏幕宽都是100vw，高100vh，就是是将窗口大小平分为 100 份;这里的屏幕指的是视口，即浏览器窗口，不受分辨率和dpr影响，还是很方便的。

#### [Flex布局](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

![flex-容器属性](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-container.jpg)

![flex-项目属性](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-project.jpg)



#### 盒子水平垂直居中的五种方法：

相对定位： 先让子盒子的左上角居中然后在向左和向上移动子盒子的宽和高的一半。缺点是需要知道子盒子具体的宽和高

```css
top: 50%;
left: 50%;
margin-left: -25px;
margin-top: - 25px;
```

绝对定位：设置子盒子的上、下、左、右都为0，然后再用margin: auto;来设置居中。不需要知道盒子具体的宽和高，但必须要有固定的宽和高。

```css
top: 0;
left: 0;
right: 0;
bottom: 0;
margin: auto;
```

相对定位+CSS3的translate：同一，先让盒子的左上角居中（left，top 50%），然后再借助translate让子盒子分别向左和向上移动盒子的一半。不需要知道盒子具体的宽和高，但不是所有浏览器都兼容。

```css
top: 50%;
left: 50%;
transform: translate(-50% -50%);
```

display: flex：利用flex布局让子盒子居中，同样也存在兼容性问题

```css
 #box{
    width:100%;
  height:100%;
  background:#eee;
  display:flex;
  justify-content: center;
  align-items: center;
}
```

利用JavaScript，获取分别获取大盒子和子盒子的宽和高，然后再通过计算让子盒子居中

#### 两边固定 中间自适应 （圣杯布局和双飞翼布局）

**圣杯布局结构**： 

> main是中间部分 必须放在文档流的最起前边 优先渲染
>
> 好处：重要的内容放在文档流前面可以优先渲染
>
> 原理：利用相对定位、浮动、负边距布局，而不添加额外标签

- 

```html
<div class="contaer">
        <div class="main"></div>
        <div class="left"></div>
        <div class="right"></div>
</div>
.contaer {
    /*3， 给父盒子添加padding  把main挤过来 */
    padding: 0 200px;
}
        
.left,
.right {
    width: 200px;
    height: 200px;
    background-color: red;
    /*1， 给左右盒子添加左浮动 */
    float: left;
    /* 4，给左右盒子添加相对于自己的定位 */
    position: relative;
}
        
.left {
    /*2， 让盒子上去 */
    margin-left: -100%;
    /* 让盒子定位在左边 */
    left: -200px;
}
.right {
    /* 2，让盒子上去 */
    margin-left: -200px;
    /*4. 让盒子定位在右边 */
    right: -200px;
}
        
.main {
    width: 100%;
    height: 200px;
    background-color: blueviolet;
    float: left;
    text-align: center;
}
```

> 1，给左中右设置左浮动 但是 mian部分的宽度为100% 所以左右元素不会上去
>
> 2，给left 一个margin-left = -100% right 的margin-left : -200px (这里是right盒子的宽度)
>
> 3，这时由于main的左右部分被挡住 只好给contaer padding值把main挤出来
>
> 4，这样做之后左右盒子也被挤过来了 所以需要给两个盒子添加定位 相对于自己 把盒子定在左右两边


也可以通过flex布局：

```css
.contaer {
    /* 给父盒子设置flex */
    display: flex;
}

.main {
    /* 中间部分  丰乐乡：1  让盒子占据剩下的所有剩余空间 */
    flex: 1;
    height: 200px;
    background-color: blueviolet;
}

.left,
.right {
    width: 200px;
    height: 200px;
    background-color: red;
}

.left {
    /* 让左侧盒子放在前边  但不是最先渲染 */css
    order: -1;
}
```

**双飞翼布局**：

> 去掉了圣杯布局中的定位和padding 但是需要在main加入一个p标签 后给p标签margin。对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局
>
> 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。

结构：

```html
<div class="contaer">
        <div class="main">
            <p>main</p>
        </div>
        <div class="left">left</div>
        <div class="right">right</div>
</div>
```


样式：

```css
.left,
.right {
    width: 200px;
    height: 200px;
    background-color: red;
    /* 给左右盒子添加左浮动 */
    float: left;
}
.left {
    /* 让盒子上去 */
    margin-left: -100%;
    
}
.right {
    /* 让盒子上去 */
    margin-left: -200px;
    
}
.main {
    width: 100%;
    height: 200px;
    background-color: blueviolet;
    float: left;
}
/* 给p添加margin*/
p {
    margin: 0 200px;
}
```


**双飞翼布局和圣杯布局的区别**：

> 除了结构上的差别 圣杯布局中 当页面很小的时候 main 会被挤下来 但是双飞翼布局不会 flex布局也不会

#### 创建一个三角形的原理

```css
#demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```

#### 清除浮动的方式

1.在子元素并级后面添加一个新元素，添加 clear：both 属性 

优点：通俗易懂，容易掌握   缺点：添加无意义空标签，不方便后期维护 

2.给父元素添加 overflow:hidden 

优点：代码较少，简单方便   缺点：不能配合定位使用 

3.：after 方法（作用于浮动元素的父元素）

```css
.clearfix:after{
  content:"";
  display: block;
  height:0;
  clear:both;
  visibility:hidden;
}
/* 为兼容 IE6,IE7，因为 ie6,ie7 不能用 after 伪类 */
.clearfix{
  zoom:1;
}
```

优点：结构和语义化完全正确   缺点：复用方式不当，会造成代码量增加



**CSS 实现单行文本溢出显示** 

```css
overflow : hidden ; 
text-overflow : ellipsis ; 
white-space : nowrap ;
```

还需要加宽度 width 属性来兼容部分浏览器 

**实现多行文本溢出显示**

```css
display : -wedkit-box ; 
-webkit-box-orient : vertical ; 
-webkit-line-clamp : 3 ; 
overflow : hidden ;
```

适用范围 : 因使用了 Webkit 的 CSS 扩展属性,该方法适用于 Webkit 浏览器 以及移动端 注: 

 -webkit-line-clamp 用来限制在一个块元素显示的文本的行数,为了实现 该效果,它需要组合其它的 webkit 属性。 

 常见结合属性： 

 display：-webkit-box； 必须结合的属性，将对象作为弹性伸缩盒 子模式显示。 

 -webkit-box-orient 必须结合的属性，设置或减缩伸缩盒对象的子 元素排列方式。 **溢出显示的另外一种显示方式** 

实现方式：

```css
div{ 
  position：relative； 
  line-height：20px； 
  max-height：40px； 
  overflow：hidden； 
} 
div：after{ 
  content : “...”; 
  position : absolute ; 
  bottom : 0 ; 
  right : 0 ; 
  padding-left : 40px ;  
  background : -webkit-linear-gradient(left , transparent , #fff 55%); 
  background : -o-linear-gradient(left , transparent , #fff 55%);   background : -moz-linear-gradient(left , transparent , #fff 55%);
    background : linear-gradient(left , transparent , #fff 55%); 
} 
```

此方法也有弊端：就是未超出行的情况下也会出现省略号 

注:

1. 将 height 设置为 line-height 的整数倍,防止超出的文字露出。
2. 给 p::after 添加渐变背景可避免文字只显示一半。 
3. 由于 ie6-7 不显示 content 内容，所以要添加标签兼容 ie6-7，兼容 ie8 需要将 ：：after 替换成 ：after

## Vue

### MVC 和 MVVM 区别

#### MVC

MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范

- Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据
- View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的
- Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。

#### MVVM

MVVM 新增了 VM 类

> ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。

MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）

整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性

> 注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明。严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。

### Vue相关

####  Vue 组件通讯有哪几种方式

> 1. props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的
>
> 2. $parent,$children 获取当前组件的父组件和当前组件的子组件
>
> 3. 父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用，用于跨级通讯)
>
> 4. $refs 获取组件实例
>
> 5. envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式
>
> 6. vuex 状态管理

**props & $emit:**

```js
<Son @changeData="changeData"></Son>

<script>
 import Son from '@/components/son'
 export default{
   name:'Father',
   components:{Son},
   methods:{
     changeData(name){
       console.log(name) //来自子组件的数据
     }
   }
 }
</script>
<el-button @click="handleEmit">通知父组件需要更改数据了</el-button>

<script>
 export default{
   name:'Son',
   methods:{
     handleEmit(){
       this.$emit('changeData','这是来自子组件的数据')
     }
   }
 }
</script>
```

**$parent & $children：**

```js
<template>
  <div>子组件</div>
</template>

<script>
export default{
  name:"Son",
  data(){
    return{
      sonData: '子组件的数据'
    }
  },
  methods:{
    sonHandle(){
      console.log('子组件的方法')
    }
  },
  created(){
    console.log(this.$parent)
    console.log(this.$parent.fatherData) //父组件的数据
    this.$parent.fantherHandle() //父组件的方法
  }
}
</script>
```



```js
<template>
  <div>
    <Son>父组件</Son>
  </div>
</template>

<script>
import Son from './son.vue'

export default{
  name: 'father',
  components:{
    Son
  },
  data(){
    return{
      fatherData: '父组件的数据'
    }
  },
  methods:{
    fantherHandle(){
      console.log('父组件的方法')
    }
  },
  mounted(){
    console.log(this.$children)
    console.log(this.$children[0].sonTitle) //子组件的数据
    this.$children[0].sonHandle() //子组件的方法
  }
}
</script>
```

这里要注意父组件要在mounted（）这个生命周期对子组件进行取值因为在这时候子组件才完成了 created 与 mounted，并且获取到的数据是一个数组的形式。

**provide $ inject：**

```js
/*父组件*/
export default{
 provide: {
   return{
     provideData: '父组件的数据'
   }
 }
}
/*子组件*/
export default{
  inject: ['provideData'],
  created () {
    console.log(this.provideName) //"父组件的数据"
  }
}
```

**$refs：**

```js
<template>
  <div>
    <Son ref="son"></Son>
  </div>
</template>

<script>
import Son from './son.vue'

export default{
  name: 'father',
  components:{
    Son
  },
  mounted(){
    console.log(this.$refs.son) /*组件实例*/
  }
}
</script>
```

**envetBus：**

需要先创建一个公共的eventBus.js，并将Vue实例暴露出去

```js
import Vue from "vue"
export default new Vue()
```

 在需要组件通信的组件A中引入eventBus.js，并通过$emit发布回调事件

```js
<template>
  <div>
    <div>组件A</div>
    <el-button @click="changeData">修改数据A</el-button>
  </div>
</template>

<script>
import { EventBus } from "../bus.js"
export default{
  data(){
    return{}
  },
  methods:{
    changeData(){
      EventBus.$emit("editData", '这是修改后的数据')
    }
  }
}
</script>
```

组件B中同样引入eventBus.js文件，并通过$on监听事件回调

```js
<template>
  <div>组件B</div>
</template

<script>
import { EventBus } from "../bus.js"
export default{
  data(){
    return{}
  },
  mounted:{
    EventBus.$on('editData',(data)=>{
      console.log(data) 
    })
  }
}
</script>
```





#### Vue 的生命周期方法有哪些 一般在哪一步发请求

![Vue生命周期](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/vue-life.jpg)

> **beforeCreate** 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问
>
> **created** 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom
>
> **beforeMount** 在挂载开始之前被调用：相关的 render 函数首次被调用。
>
> **mounted** 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点
>
> **beforeUpdate** 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程
>
> **updated** 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。
>
> **beforeDestroy** 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。
>
> **destroyed** Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
>
> **activated** keep-alive 专属，组件被激活时调用
>
> **deactivated** keep-alive 专属，组件被销毁时调用



异步请求在哪一步发起？**

> 可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
>
> 如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
>
> - 能更快获取到服务端数据，减少页面  loading 时间；
> - ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；



Vue 的父子组件生命周期钩子函数执行顺序**

>**加载渲染过程:**
>
>父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted
>
>**子组件更新过程:**
>
>父 beforeUpdate->子 beforeUpdate->子 updated->父 updated
>
>**父组件更新过程:**
>
>父 beforeUpdate->父 updated
>
>**销毁过程:**
>
>父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed



####  vue 内置指令![vue内置指令](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/vue-command.jpg)

#### 关于 Vue 的单向数据流

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

> 注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告

如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改。

#### computed 和 watch 的区别和运用的场景

computed 是[计算属性](https://juejin.cn/post/6956407362085191717)，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。

[watch](https://juejin.cn/post/6954925963226382367)监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。

计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑计算属性原理详解 





#### v-model 原理

v-model 其实就是语法糖

v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

>text 和 textarea 元素使用 value property 和 input 事件；
>
>checkbox 和 radio 使用 checked property 和 change 事件；
>
>select 字段将 value 作为 prop 并将 change 作为事件。

在普通标签上:

```html
<input v-model="sth" />  //这一行等于下一行
<input v-bind:value="sth" v-on:input="sth = $event.target.value" />
```

在组件上:

```html
<currency-input v-model="price"></currentcy-input>
<!--上行代码是下行的语法糖
 <currency-input :value="price" @input="price = arguments[0]"></currency-input>
-->

<!-- 子组件定义 -->
Vue.component('currency-input', {
 template: `
  <span>
   <input
    ref="input"
    :value="value"
    @input="$emit('input', $event.target.value)"
   >
  </span>
 `,
 props: ['value'],
})
```

#### Vue数据双向绑定原理

vue的响应式基本原理：

> 1、vue会遍历此data中对象所有的属性，
>
> 2、并使用Object.defineProperty进行数据劫持，把这些属性全部转为getter/setter，
>
> 3、而每个组件实例都有watcher对象，
>
> 4、它会在组件渲染的过程中把属性记录为依赖，
>
> 5、之后当依赖项的 setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

eg：

Object.defineProperty( ):

```js
var person = {}
var name = '';
Object.defineProperty(person, 'name', {
  set: function (value) {
    name = value;
  },
  get: function () {
    return "My name is " + name
  }
})
 
person.name = 'Jayhodon';
console.log(person.name);  // My name is Jayhodon
```



vue的响应式原理设计三个重要对象：Observer，Watcher，Dep。

> Observer对象：vue中的数据对象在初始化过程中转换为Observer对象。
>
> Watcher对象：将模板和Observer对象结合在一起生成Watcher实例，Watcher是订阅者中的订阅者。
>
> Dep对象：Watcher对象和Observer对象之间纽带，每一个Observer都有一个Dep实例，用来存储订阅者Watcher。

当属性变化会执行主题对象Observer的dep.notify方法， 这个方法会遍历订阅者Watcher列表向其发送消息， Watcher会执行run方法去更新视图。模板编译过程中的指令和数据绑定都会生成Watcher实例，实例中的watch属性也会生成Watcher实例。

总的来说就是：

> 1、在生命周期的initState方法中将data，prop，method，computed，watch中的数据劫持， 通过observe方法与Object.defineProperty方法将相关对象转为换Observer对象。
>
> 2、然后在initRender方法中解析模板，通过Watcher对象，Dep对象与观察者模式将模板中的 指令与对象的数据建立依赖关系，使用全局对象Dep.target实现依赖收集。
>
> 3、当数据变化时，setter被调用，触发Object.defineProperty方法中的dep.notify方法， 遍历该数据依赖列表，执行器update方法通知Watcher进行视图更新。



使用Object.defineProperty实现监听变量:

实现步骤：

Observer：

 用来劫持并监听所有属性，如果有变动的，就通知订阅者。

```js
function Observer(data) {
    this.data = data;
    this.walk(data);
}

Observer.prototype = {
    walk: function(data) {
        var self = this;
        Object.keys(data).forEach(function(key) {
            self.defineReactive(data, key, data[key]);
        });
    },
    defineReactive: function(data, key, val) {
        var dep = new Dep();
        var childObj = observe(val);// 递归遍历所有子属性
        Object.defineProperty(data, key, {
            enumerable: true,
            configurable: true,
            get: function getter () {
                if (Dep.target) {
                    dep.addSub(Dep.target);//判断是否需要添加订阅者，并添加订阅者
                }
                return val;
            },
            set: function setter (newVal) {
                if (newVal === val) {
                    return;
                }
                val = newVal;
                dep.notify();//如果数据发生了变化，则通知所有的订阅者
            }
        });
    }
};

function observe(value, vm) {
    if (!value || typeof value !== 'object') {
        return;
    }
    return new Observer(value);
};

//Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数
function Dep () {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};
Dep.target = null;
```

Watcher：

 可以收到属性的变化通知并执行相应的函数，从而更新视图。

```js
function Watcher(vm, exp, cb) {
    this.cb = cb;
    this.vm = vm;
    this.exp = exp;
    this.value = this.get();  // 将自己添加到订阅器的操作
}

Watcher.prototype = {
    update: function() {
        this.run();
    },
    run: function() {
        var value = this.vm.data[this.exp];
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal);
        }
    },
    get: function() {
        Dep.target = this;  // 缓存自己
        var value = this.vm.data[this.exp]  // 强制执行监听器里的get函数
        Dep.target = null;  // 释放自己
        return value;
    }
};
```

这时只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了

```js
function SelfVue (data, el, exp) {
    this.data = data;
    observe(data);
    el.innerHTML = this.data[exp];  // 初始化模板数据的值
    new Watcher(this, exp, function (value) {
        el.innerHTML = value;
    });
    return this;
}
```

完整版参考自：[vue的双向绑定原理及实现](https://www.cnblogs.com/libin-1/p/6893712.html)    [源 码](https://github.com/canfoo/self-vue/tree/master/v3)



使用ES6的proxy简单实现监听变量:

```js
let obj = {
 msg: {
  a: 10
 },
 arr: [1, 2, 3]
}

let handler = {
 get(target, key){
  //懒监听，去获取的时候才监听对象里面的对象，而不是直接递归循环监听
  if(typeof target[key] === 'object' && target[key] !== null){
   return new Proxy(target[key], handler);
  }
  return Reflect.get(target, key);
 },
 set(target, key, value){
  console.log('set', target, key, value);
  //数组新增会执行两次，一次是修改length，一次是添加值
  let oldValue = target[key];
  if(!oldValue){
   //找不到老值，新增
  }else if(oldValue !== value){
   //老值和新值不相等，修改
  }
  return Reflect.set(target, key, value);
 }
}

let proxy = new Proxy(obj, handler)
proxy.arr.push(4);
proxy.msg.a = 50;
proxy.msg.b = 60;
proxy.c = 70;
```

区别：

> 1、语法层面上
>
> defineProperty只能响应首次渲染时候的属性，
>
> defineProperty无法一次性监听所有属性，必须通过遍历或者递归的方式来实现且无法监听新增的属性，对于数组defineProperty则需要劫持数组方法。
>
> Proxy需要的是整体监听，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的。
>
> 2、兼容层面上
>
> vue2.x之所以只能兼容到IE8就是因为defineProperty无法兼容IE8,其他浏览器也会存在轻微兼容问题。
>
> proxy的话除了IE，其他浏览器都兼容，这次vue3还是使用了它，说明vue3直接放弃了IE的兼容考虑。



#### vue 中使用了哪些设计模式

>1.工厂模式 - 传入参数即可创建实例
>
>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode
>
>2.单例模式 - 整个程序有且仅有一个实例
>
>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉
>
>3.发布-订阅模式 (vue 事件机制)
>
>4.观察者模式 (响应式数据原理)
>
>5.装饰模式: (@装饰器的用法)
>
>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略



#### Vue3.0 和 2.0 的响应式原理区别

### vue-router

#### vue-router 中常用的路由模式实现原理吗

##### **hash 模式**

1. location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
2. 可以为 hash 的改变添加监听事件

```javascript
window.addEventListener("hashchange", funcRef, false);
```

每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了

> 特点：兼容性好但是不美观

##### **history 模式**

利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。

这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。

> 特点：虽然美观，但是刷新会出现 404 需要后端进行配置



### vuex

#### 谈一下对 vuex 的个人理解

vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。

主要包括以下几个模块：

>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
>
>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
>
>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
>
>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
>
>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。



#### Vuex 页面刷新数据丢失怎么解决

 需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件。推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中



## React

> 类组件可以使用其他特性，如状态 state 和生命周期钩子。
>
> 当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。
>
> 函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。




## TypeScript

> Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。

### Typescript的优缺点：

> **优点：**
>
> 1：快速简单，易于学习。
>
> 2：编译时提供错误检查， 在代码运行前就会进行错误提示。
>
> 3：支持所有的JS库。
>
> 4：支持ES6，提供了ES6所有优点和更高的生产力。
>
> 5：使用继承提供可重用性。
>
> 6：有助于代码结构。
>
> 7：通过定义模块来定义命名空间。
>
> **缺点：**
>
> 1：需要长时间的来编译代码。
>
> 2：在使用第三方库时，需要有三方库的定义文件，并不是所有三方库都提供了定义文件，提供的定义文件是否准确也值得商榷。

### [泛型](https://typescript.bootcss.com/generics.html)及其作用作用是什么：

> 泛型代表的是泛指某一类型，更像是一个类型变量。由尖括号包裹<T>。主要作用是创建逻辑可复用的组件。泛型可以作用在函数、类、接口上。


 函数：

```tsx
function greet<T>(name: T) {}
```

类：

```tsx
class createObj<T> {
  name: T
}
```


接口：

```tsx
interface IF<T> {
  name: T
}
```

相关[试题](https://www.jianshu.com/p/c8aaba6e8ce0)









## 浏览器相关

### Http缓存：

> http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。
>
> http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

![http-cache-2](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-2.jpg)

#### 1、http缓存的分类：

 根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) 强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。

**强制缓存**
强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。

![http缓存-强制](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-force-cache.jpg)

**协商缓存**
当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现

![http缓存-协商](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-negotiation-cache.jpg)

#### 2、如何使用HTTP缓存 ？

一般需要缓存的资源有html页面和其他静态资源：
**html页面缓存的设置主要是在标签中嵌入标签，这种方式只对页面有效，对页面上的资源无效,静态资源的缓存一般是在web服务器上配置的**

1. html页面禁用缓存的设置如下：

```html
<meta http-equiv="pragma" content="no-cache">
// 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求
<meta http-equiv="cache-control" content="no-cache">
// 其他主流浏览器识别的标签
<meta http-equiv="expires" content="0">
// 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段
```

2. html设置缓存如下：

```html
<meta http-equiv="Cache-Control" content="max-age=7200" />
// 其他主流浏览器识别的标签
<meta http-equiv="Expires" content="Mon, 20  Aug 2018 23:00:00 GMT" />
// 仅有IE浏览器才识别的标签
```



#### 3、缓存控制

**HTTP/1.1**定义的 [`Cache-Control`](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FCache-Control) 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。

**没有缓存**

```js
Cache-Control: no-store
```

缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。



**缓存但重新验证**

```undefined
Cache-Control: no-cache
```

此方式下，每次有请求发出时缓存会将此请求发到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期（返回304），则缓存才使用本地缓存副本



**私有和公共缓存**

```cpp
Cache-Control: private
Cache-Control: public
```

"public" 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。

而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。



**过期**

```swift
Cache-Control: max-age=31536000
```

过期机制中，最重要的指令是 "`max-age=`"，表示资源能够被缓存（保持新鲜）的最大时间。



**浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？**

> 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载 相应的资源并进行离线存储。如果已经访问过 app，并且资源已经离线存储了， 如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资 源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如 果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文 件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源



#### 4、http报头&&状态码

> HTTP请求报文由请求行、请求头部、空行和请求数据4个部分组成，下图是请求报文的一般格式。
>
> HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。



![http缓存-3](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-3.jpg)



| 状态码 | 描述                     |
| ------ | ------------------------ |
| 1xx    | 提示信息，请求被成功接收 |
| 2xx    | 成功，请求被成功处理 200 |
| 3xx    | 重定向相关 304           |
| 4xx    | 客户端错误 404           |
| 5xx    | 服务端错误 500           |

> 200 成功处理了请求，一般情况下都是返回此状态码；
> 201 请求成功并且服务器创建了新的资源。
> 202 接受请求但没创建资源；
> 203 返回另一资源的请求；

>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。
>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。

>400 服务器不理解请求的语法。
>401 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
>403 服务器拒绝请求。
>404 服务器找不到请求的网页。
>408 服务器等候请求时发生超时。
>410 如果请求的资源已永久删除，服务器就会返回此响应。
>413 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
>414 请求的 URI（通常为网址）过长，服务器无法处理。

>500 （服务器内部错误） 服务器遇到错误，无法完成请求。
>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。



#### 5、HTTP与HTTPS有什么区别？

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。

简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS和HTTP的区别主要如下：

> 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
>
> 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
>
> 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
>
> 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### GET和POST的区别



> GET在浏览器回退时是无害的，而POST会再次提交请求。
> GET产生的URL地址可以被Bookmark，而POST不可以。
> GET请求会被浏览器主动cache，而POST不会，除非手动设置。
> GET请求只能进行url编码，而POST支持多种编码方式。
> GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
> GET请求在URL中传送的参数是有长度限制的，而POST么有。
> 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
> GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
> GET参数通过URL传递，POST放在Request body中。

首先从安全性讲，get和post都一样，没啥所谓的哪个更安全
get请求参数在url地址上，直接暴露，post请求的参数放body部分，按F12也直接暴露了，所以没啥安全性可言。

GET参数通过URL传递，POST放在Request body中”这个其实也不准，post请求也可以没body，也可以在url传递呢？

**GET和POST有一个重大区别**
GET产生一个TCP数据包；POST产生两个TCP数据包。也就是说：
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。



### WebStorage：

Web Storage的目的是为了克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是：

- 提供一种在cookie之外存储会话数据的途径。
- 提供一种存储大量可以跨会话存在的数据的机制。

Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。从字面意思就可以很清楚的看出来，sessionStorage将数据保存在session中，浏览器关闭也就没了；而localStorage则一直将数据保存在客户端本地。其API提供的方法有以下几种：

```csharp
    - setItem (key, value) ——  保存数据，以键值对的方式储存信息。

    - getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。

    - removeItem (key) ——  删除单个数据，根据键值移除对应的信息。

    - clear () ——  删除所有的数据

    - key (index) —— 获取某个索引的key
```

#### localStorage

localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。使用方法如下：

```dart
var storage = null;
if(window.localStorage){              //判断浏览器是否支持localStorage
     storage = window.localStorage;     
     storage.setItem("name", "Rick");    //调用setItem方法，存储数据
     alert(storage.getItem("name"));     //调用getItem方法，弹框显示 name 为 Rick
     storage.removeItem("name");     //调用removeItem方法，移除数据
     alert(storage.getItem("name"));   //调用getItem方法，弹框显示 name 为 null
}
```

localStorage 相对sessionStorage简单一点，需要注意的地方不是很多。

#### sessionStorage

sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。需要注意的有以下几点：

- 页面刷新不会消除数据;
- 只有在当前页面打开的链接，才可以访sessionStorage的数据；
- 使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据;



#### WebStorage与cookie的区别：

> cookie是在HTML4中使用的给客户端保存数据的，也可以和session配合实现跟踪浏览器用户身份；

 

**相同点：**

 cookie，localStorage，sessionStorage都是在客户端保存数据的，存储数据的类型：都是字符串。

**不同点：**

1. 生命周期：

> 1）、cookie如果不设置有效期，那么就是临时存储（存储在内存中），是会话级别的，会话结束后，cookie也就失效了，如果设置了有效期，那么cookie存储在硬盘里，有效期到了，就自动消失了。
>
> 2）、localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。
>
> 3）、sessionStorage仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。
>
> 可以简单的理解为：sessionStorage，没有设置有效期的cookie。
>
> 如果说把cookie的有效期设置为永远永远，永久，那么就是localStorage。
>
> cookie没有设置有效期，那么就是sessionStorage                  

2. 网络流量：cookie的数据每次都会发给服务器端，而localstorage和sessionStorage不会与服务器端通信，纯粹为了保存数据，所以，webstorage更加节约网络流量。

3. 大小限制：cookie大小限制在4KB，非常小；localstorage和sessionStorage在5M

4. 安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获。



#### cookie的配置：

通常我们有两种方式给浏览器设置或获取Cookie：

- 第一种 通过 HTTP 方式对 Cookie 进行赋值，又分为 Request 和 Response：

- - HTTP Response Headers 中的 Set-Cookie Header
  - HTTP Request Headers 中的 Cookie Header

- 第二种 通过JavaScript对document.cookie进行赋值或取值。

**1. HTTP Cookie**

Set-Cookie Header，除了必须包含Cookie正文，还可以选择性包含6个属性：

```text
path、domain、max-age、expires、secure、httponly
```

它们之间用英文分号和空格（"; "）连接，示例：

```http
Set-Cookie:
  key=value; 
  path=path;
    domain=domain;
    max-age=max-age-in-seconds;
    expires=date-in-GMTString-format;
    secure; httponly
```

**JS Cookie**

在浏览器端，通过 document.cookie 也可以设置Cookie，JS Cookie 的内容除了必须包含正文之外，还可选5个属性：

```text
path、domain、max-age、expires、secure
```

下面是简单的示例：

```js
document.cookie = "key=value; path=path; domain=domain; max-age=max-age-in-seconds; expires=date-in-GMTString-format; secure";
```

JS 中设置 Cookie 和 HTTP 方式相比较，少了对 **HttpOnly** 的控制，是因为 JS 不能读写HttpOnly Cookie。



## 浏览器安全相关

### 盗用cookie的手段

在别的浏览器中来冒用合法用户访问系统；黑客自然不能手动拿你浏览器中的cookie值，除非黑客就是你身边的人，那他就不是黑客了，是盗贼；

黑客都是靠技术手段获取别人的东西，例如：利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页中，然后自动从用户浏览器中获取cookie的值，此技术手段被称为[**XSS攻击**](https://blog.csdn.net/zemprogram/article/details/109451863)；

**如果cookie中设置了HttpOnly属性，且为true，那么通过js脚本将无法读取到cookie信息，这样就能有效的防止XSS攻击，防止cookie内容被盗窃。**

### SYN攻击

　　 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.
    Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。
    Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.



## 参考文献

[【THE LAST TIME】彻底吃透 JavaScript 执行机制](https://juejin.cn/post/6844903955286196237)

[【THE LAST TIME】一文吃透所有JS原型相关知识点](https://juejin.cn/post/6844903984335945736)

[你所不知道的HostOnly Cookie](https://imququ.com/post/host-only-cookie.html)

[计算机网络--网络攻击XSS与CSRF](https://blog.csdn.net/zemprogram/article/details/109451863)

[CSS Flex 弹性布局（一） - 阮一峰](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

[CSS Flex 弹性布局（二） - 阮一峰](https://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

[CSS Grid 网格布局 - 阮一峰](https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)

[TypeScript 中文手册](https://typescript.bootcss.com/)

[TypeScript-相关试题](https://www.jianshu.com/p/c8aaba6e8ce0)

[深度剖析JavaScript ES5/ AMD/ CMD/ COMMONJS/ ES6模块化](https://blog.csdn.net/qq_27575925/article/details/113758050)

