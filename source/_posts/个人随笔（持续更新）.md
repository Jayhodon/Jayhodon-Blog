---

title: 个人随笔（持续更新）
date: 2021-05-28 18:07:56
tags: [前端,个人知识库]
categories: [前端,个人知识库]
summary: '该博文是博主本人自己归纳整合的一些面经以及一些零零散散的基础知识点，一方面方便自己以后复习查看，另一方面也是做一个简单的分享。'
---

> 该博文是博主本人自己归纳整合的一些面经以及一些零零散散的基础知识点，一方面方便自己以后复习查看，另一方面也是做一个简单的分享。

## JavaScript:



### Jsonp原理：

 Jsonp的全称为：json with padding ，意为填充式的json。

> 1、Ajax直接请求普通文件存在跨域无权限访问的问题，不管是静态页面、动态页面、web服务，只要是跨域请求，一律不准。
>
> 2、不过我们发现，web页面调用js文件则不受跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如<\script>、<\img>、<\iframe>）。
>
> 3、于是可以判断，当前阶段如果想通过纯web端跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。
>
> 4、恰巧我们知道有一种叫做JSON的**纯字符数据格式**可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据。
>
> 5、这样，解决方案就呼之欲出了，web服务端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装进去。
>
> 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来很像ajax，但其实并不一样。
>
> 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，简称**JSONP**。<u>该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名包裹在JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</u>

可以说Jsonp就是为了跨域而生的了。

### Jsonp的实现：

#### 1、远程调用其它服务器上的js文件（跨域成功）

```html
<script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
```

#### 2、远程调用js

在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。

```html
<script type="text/javascript">
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
</script>
<script type="text/javascript" src="http://remoteserver.com/remote.js"></script>

```

remote.js文件代码如下：

```java
localHandler({"result":"我是远程js带来的数据"});
```

运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。

这样一来跨域远程获取数据的目的基本实现了，但是又一个问题出现了，怎么让远程js知道它应该调用的本地函数呢？

#### 3、动态生成js脚本

只要服务端提供的js脚本是动态生成的，这样调用者就可以传一个参数过去告诉服务端，“我想要一段调用xxx函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。

看jsonp.html页面的代码：

```html
<script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
</script>
```

利用编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。

我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。
OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html

```javascript
flightHandler({    "code": "CA1998",    "price": 1780,    "tickets": 5});
```

#### 4、封装代码

jQuery如何实现jsonp调用？

```js
<script type="text/javascript" src=jquery.min.js"></script>
<script type="text/javascript">
   jQuery(document).ready(function(){
   $.ajax({
        type: "get",
        async: false,
        url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",                       dataType: "jsonp",
        jsonp: "callback",
        //传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)             
        jsonpCallback:"flightHandler",
        //自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
        success: function(json){
              alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
                 },             
        error: function(){                 
                    alert('fail');             
               }         
        });    
   }); 
```

jquery在处理jsonp类型的ajax时，自动帮你生成回调函数并把数据取出来供success属性方法来调用。

#### ajax和jsonp的区别：

1、ajax和jsonp这两种技术在调用方式上看起来很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jQuery把jsonp作为ajax的一种形式进行了封装。

2、但ajax和jsonp其实本质上是不同的东西，ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加。



### 原型与原型链：

ES6之前中并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实

![原型与原型链](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/prototype.png)

#### 原型（`prototype`）

- JS所有的函数都有prototype属性，只有函数才有
- 其属性和方法都能被构造函数实例化的对象所共同访问

- `constructor`存在于每个函数的`prototype`属性中，其指向了函数本身

#### 原型链 (`_proto_`）

- JS中的对象会有个`_proto_`属性，指向了创建他的构造函数的`prototype`,而函数比较特殊也有这个属性

- 当JS搜索引擎查找对象中的属性或者方法时，如果在该对象上没有该属性和方法的话，会通过原型链一层一层往上查找
- 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向下搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

```js
var Person = function(name,age) {
   this.name = name;
   this.age = age;
}
Person.prototype.run = function() {
    console.log('running');
}
var me = new Person('小明',10);
// ➀ 每个对象都有一个__proto__属性，并且指向他的prototype原型对象。
console.log(me.__proto__===Person.prototype); // true
// ➁ 每个构造函数都有一个prototype原型对象,prototype原型对象的constructor等于构造函数本身
console.log(Person.prototype.constructor==Person); // true

//原型相关的知识考点一般就是围绕以下：
console.log(Person===Person.prototype.constructor)  // true
console.log(person.__proto__ == Person.prototype) // true
console.log(person.__proto__.constructor == Person) // true
console.log(person.constructor == Person) // true
```

当每创建一个Person构造函数时，在Person构造函数中，为每一个对象都添加了一个run方法，也就是说构造函数每执行一次就会创建一个新的run方法。

一个还好，如果创建了一百个实例，一千个甚至上万个呢，这时候就体现出原型的好处了，我们可以把run方法放到构造函数的prototype上，这时候只需要创建一个，而且每一个实例都可以访问到。

prototype相当于所有实例对象可以访问的一个公共容器，实例对象的`__prorunto__`指向构造函数的`prototype`，从而实现**继承**。

**经典图：**

![原型经典图](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/classic-prototype.jpg)

#### 如何准确判断一个变量是数组类型? 

instanceof 用于判断引用类型属于哪个构造函数的方法 

```js
var arr = [];
arr instanceof Array; //true 
typeof arr; //object typeof 是无法判断是否为数组的
```

instanceof 是用来判断实例的_proto_和构造函数的 prototype 是否指 向一个原型对象，

但是有一个弊端，只要出现在一条原型链上的，都会返回 true（每个函数都有 prototype，每个对象都有一个内部属性__proto__，其指向它的原型对象。原 型对象也是一个对象，所以也有__proto__） 

这个时候要用实例__proto__.constructor 更加严谨 

```js
var arr = [ ]; console.log(arr instanseof Array); //true console.log(arr.__proto__.constructor === Array) //true
console.log( arr instanceof Array ) 
console.log( arr.construct == Array) 
console.log( Array.isArray( arr ))
```



#### new 操作符在创建实例的时候经历了哪几个阶段 

new 创建了一个对象，共经历了 4 个阶段： 

1. 创建一个空对象 
2. 设置原型链 
3. 让实例化对象中的 this 指向对象，并执行函数体 
4. 判断实例化对象的返回值类型



#### 类型的判断方法

**1、typeof**

>未定义、未初始化：返回 `"undefined"`
>
>布尔值：返回 `"boolean"`
>
>字符串：返回 `"string"`
>
>数值(包括NAN)：返回 `"number"`
>
>对象、null：返回 `"object"`， null 表示空对象指针
>
>函数：返回 `"function"`
>
>**注意**：`typeof`可以判断基本类型，无法判断对象的类型或者null

**2、instanceof**

>如果变量是引用类型，可以使用instanceof判断，检测基本类型时，会返回false。
>
>原理：判断变量的原型链上是否有构造函数的prototype属性
>
>**注意：空对象{}的判断问题**        //true

**3、Object.prototype.toString**

> 所有的数据类型都可以使用此方法进行检测，且非常精准。如：
>
> Object.prototype.toString.call(obj) === '[object Object]'





#### 了解更多相关：

ES5继承实现、ES6类实现、typeof&&instanceof原理：https://juejin.cn/post/6844903984335945736



### 继承



### This:

**1. 默认绑定与隐式绑定**

让我们看看下面这个例子：

```js
function foo() { 
    console.log(this.bar); 
} 
var bar = "bar1"; 
var o2 = {bar: "bar2", foo: foo}; 
var o3 = {bar: "bar3", foo: foo}; 
foo();            // "bar1" – 默认绑定
o2.foo();          // "bar2" – 隐式绑定
o3.foo();          // "bar3" – 隐式绑定
```

foo()这种调用方法，就是默认绑定。如果在非严格模式下，this就是全局对象，浏览器当中就是window。而如果在严格模式（use strict）下，this就会是undefined。

之所以这是默认绑定，因为foo的调用不属于任何人，前面没有任何限定条件。这是最简单的绑定。

o2.foo()和o3.foo()这两种调用方法，都是隐式绑定。Foo是作为o2和o3的方法而调用的，那么谁调用foo，this就指向谁。在上面的例子中，o2.foo()中的this指向o2，因此this.bar就是o2当中的bar: “bar2”；同理，o3.foo()打印出来的就是o3中的”bar3”。

**2. 显式绑定**

```js
function foo() { 
console.log(this.bar); 
} 
var bar = "bar1"; 
var obj = {bar: "bar2"}; 

foo();          // "bar1"   默认绑定
foo.call(obj);     // "bar2"  显式绑定，使用obj作为"this" 
```

如果foo是通过call、apply或者bind调用的，那么这种调用就是显式绑定。这种绑定中,this的指向就是这三个函数中传递的第一个参数。

**3. 关键字new绑定**

```js
function foo() { 
    this.baz = "baz"; 
    console.log(this.bar + " " + baz); 
} 
var bar = "bar"; 
var baz = new foo(); 
```

如果把new这个关键字放在一个函数调用的前面，JS编译器会做这四件事情：

>1. 创建一个新的空的对象
>2. 把这个对象链接到原型对象上
>3. 这个对象被绑定为this
>4. 如果这个函数不返回任何东西，那么就会默认return this

上面的例子，最终会输出undefined undefined。这是因为baz这个变量并没有bar这个属性，而baz此时只被定义，没有被赋值，因此baz也是undefined。

**4. 箭头函数**

箭头函数会无视以上所有的规则，this的值就是函数创建时候所在的lexical scope中的this，而和调用方式无关。可以对比下面两个例子：

```js
function Person(){
  this.age = 0;
  setTimeout(function () {
    console.log(this.age);     // 输出undefined
  }, 1000);
}
var p = new Person();
function Person(){
  this.age = 10;
  setTimeout(()=> {
    console.log(this.age);     // 输出10
  }, 1000);
}
var p = new Person();
```

在上面没有使用箭头函数的例子当中，setTimeout内部的函数是被global调用的，而global没有age这个属性，因此输出undefined。

第二个例子使用了箭头函数，this就会使用lexical scope中的this，就是Person，因此输出10。

```js
var name = 'Nicolas';
function Person(){
    this.name = 'Smiley';
    this.sayName=function(){
        console.log(this); 
        console.log(this.name); 
    };
    setTimeout(this.sayName, 0);     *// 第二次输出*
}
var person = new Person();
person.sayName();   *// 第一次输出*
```

第一次输出的是Person, Smiley。第二次输出的结果是window，Nicolas。尽管setTimeout是在构造函数中定义的，但是调用的时候，是在window中调用。

```js
function Person() {
  this.name = "Smiley";
  this.sayName = function(){
    console.log(this);
    console.log(this.name); 
  };
}
 
let person = new Person();
let sayNameCopy = person.sayName;
sayNameCopy();
```

答案是window和undefined。因为，这个时候符合默认绑定的规则。

![this指向](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/this.jpg)

**5. 绑定优先级**

如果多重绑定规格都适用，那么绑定规则的优先级顺序是这样的：

>1. 箭头函数
>2. 关键字new调
>3. 显式绑定
>4. 隐式绑定
>5. 默认绑定

箭头函数优先级最高，会无视2-5绑定规则。而默认绑定优先级最低，只有其他绑定都不使用的时候，才会使用默认绑定。

### Promise：

> Promise是异步编程的一种解决方案，它比传统的解决方案--回调函数和事件--更合理且更加强大，它最早是由社区提出并实现，后面ES6将其写进了语言标准，统一了用法，也提供了Promise。

#### 用法：

##### 1.创建Promise实例：

```jsx
const promise = new Promise(function(resolve, reject) {
    if (/*异步操作成功*/) {
        resolve(value)
    } else {
        reject(error)
    }
})
```

- Promise构造函数接受一个函数作为参数，该函数接受两个参数，分别是resolve和reject，它们是两个函数，是由javascript引擎提供，不用自己部署。
- resolve作用是将Promise对象状态由‘未完成’变为‘成功’，也就是Pending -> Fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去，而rejected函数则是将Promise对象状态由‘未完成’变为‘失败’，也就是Pending -> Rejected，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。
- Promise 可以分为四个状态：
  -  Pending：初始状态，异步操作仍在进行中。
  -  Fulfilled：操作成功，它调用`.then`回调，例如`.then(onSuccess)`。
  -  Rejected: 操作失败，它调用`.catch`或`.then`的第二个参数（如果有）。 例如`.catch(onError)`或`.then(..., onError)`。
  -  **Settled**：这是 promise 的最终状态。promise 已经死亡了，没有别的办法可以解决或拒绝了。 `.finally`方法被调用。
- **一旦状态改变就不会再发生变化**（两种状态改变：成功或失败）

##### 2.Promise的方法：

> then方法: 这个方法是定义在原型对象Promise.prototype上的，它的作用是为Promise实例添加状态改变时的回调函数。它返回的是一个新的Promise实例，注意，不是原来的那个Promise实例，因此可以采用链式写法，即then方法后面再调用一个then方法。
> Promise实例生成后，可用then方法分别指定两种状态回调函数，then方法可用接受两个回调函数作为参数：
> （1）  Promise对象状态改为Resolved时调用（必须）
> （2） Promise对象状态改为Rejected时调用（可选）
> （3） 基本用法：

```jsx
function sleep(ms) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve, ms);
    })
}
sleep(500).then( ()=> console.log("finished"));
```

这段代码定义了一个函数sleep，调用后，等待了指定参数（500）毫秒后执行then中的函数。值得注意的是，Promise新建后就会立即执行。



> catch方法: 这个方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
>
> 我们可以使用`then`函数的第二个参数来处理错误。 但是，请注意，`catch`将不再执行。

```jsx
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```

上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数，如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误，另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。

如果Promise状态已经变成resolved，再抛出错误是无效的。Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数）就使用catch方法



> finally方法: `finally`方法只在 Promise 状态是 `settled` 时才会调用。
>
> 如果你希望一段代码即使出现错误始终都需要执行，那么可以在`.catch`之后使用`.then`。
>
> 或者可以使用`.finally`关键字:

```js
Promise.resolve()
  .then(a)
  .then(b)
  .then(c)
  .then(d)
  .catch(console.error)
  .finally(() => console.log('always called'));
```



##### 3 Promise 类方法：

我们也可以直接使用 `Promise` 对象中四种静态方法。

- Promise.all
- Promise.reject
- Promise.resolve
- Promise.race

> Promise.resolve 和 Promise.reject这两个是帮助函数，可以让 Promise 立即解决或拒绝。可以传递一个参数，作为下次 `.then` 的接收：



> 使用 `Promise.all` 并行执行多个 Promise ,通常Promise 是一个接一个地依次执行的，但是你也可以并行使用它们。假设是从两个不同的api中轮询数据。如果它们不相关，我们可以使用`Promise.all()`同时触发这两个请求。

```js
const a = () => new Promise((resolve) => setTimeout(() => resolve('a'), 2000));
const b = () => new Promise((resolve) => setTimeout(() => resolve('b'), 1000));
const c = () => new Promise((resolve) => setTimeout(() => resolve('c'), 1000));
const d = () => new Promise((resolve) => setTimeout(() => resolve('d'), 1000));

console.time('promise.all');
Promise.all([a(), b(), c(), d()])
  .then(results => console.log(`Done! ${results}`))
  .catch(console.error)
  .finally(() => console.timeEnd('promise.all'));
```

解决这些 Promise 要花多长时间？ 5秒？ 1秒？ 还是2秒？



> Promise.race(iterable) 方法: 返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝

```js
const a = () => new Promise((resolve) => setTimeout(() => resolve('a'), 2000));
const b = () => new Promise((resolve) => setTimeout(() => resolve('b'), 1000));
const c = () => new Promise((resolve) => setTimeout(() => resolve('c'), 1000));
const d = () => new Promise((resolve) => setTimeout(() => resolve('d'), 1000));

console.time('promise.race');
Promise.race([a(), b(), c(), d()])
  .then(results => console.log(`Done! ${results}`))
  .catch(console.error)
  .finally(() => console.timeEnd('promise.race'));
```

输出 `b`。使用 `Promise.race`，最先执行完成就会是最后的返回结果。

在某些情况下，它可以派上用场，比如计时请求或批量处理请求数组。

```js
Promise.race([
fetch('http://slowwly.robertomurray.co.uk/delay/3000/url/https://api.jsonbin.io/b/5d1fb4dd138da811182c69af'),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error('request timeout')), 1000))
])
.then(console.log)
.catch(console.error);
```



#### 关于Promise 的问题：

**1.async await：**

```js
let a;
const b = new Promise((resolve, reject) => {
  console.log('p1');
  resolve();
}).then(() => {
  console.log('p2');
}).then(() => {
  console.log('p3');
}).then(() => {
  console.log('p4');
});

a = new Promise(async (resolve, reject) => {
  console.log(a);
  await b;
  console.log(a);
  console.log('after1');
  await a
  resolve(true);
  console.log('after2');
});

console.log('end');

//p1 -> undefined -> end -> p2 -> p3 -> p4 -> p{pending} -> after1
```

> 第一个输出 p1，是因为 Promise 里的方法立即执行。接着调用 resolve，只不过 then 里的方法等下一个周期
>
> 第二个输出 undefined，是因为立即执行执行 a 内部的方法，先 console.log(a)，但此时的 a 还没赋值给左边的变量，所以只能是 undefined。然后 await b 就得等下一个周期执行了。
>
> 第三个输出 end，自然不意外。
>
> 接着输出 p2，p3，p4，是因为 await b 等待他执行完了，才轮到 a 内部继续执行。
>
> 输出 Promise { pending }，事件都进入了循环，a 肯定已经被赋值成了 Promise 对象。所以第二遍 console.log(a)，自然就输出这个了。
>
> 输出 after1 不奇怪。
>
> await a 时，a 是必须等待 Promise 的状态从 pending 到 fullfilled 才会继续往下执行，可 a 的状态是一直得不到更改的，所以无法执行下面的逻辑。只要在 await a 上面加一行 resolve() 就能让后面的 after 2 得到输出



**2..如何限制并行 Promise？**

要做到这一点，我们需要以某种方式限制`Promise.all`。假设你有许多并发请求要执行。 如果使用 `Promise.all` 是不好的（特别是在API受到速率限制时）。 因此，我们需要一个方法来限制 Promise 个数， 我们称其为`promiseAllThrottled`。

```js
// simulate 10 async tasks that takes 5 seconds to complete.
const requests = Array(10)
  .fill()
  .map((_, i) => () => new Promise((resolve => setTimeout(() => { console.log(`exec'ing task #${i}`), resolve(`task #${i}`); }, 5000))));

promiseAllThrottled(requests, { concurrency: 3 })
  .then(console.log)
  .catch(error => console.error('Oops something went wrong', error));
```

以上代码将并发限制为并行执行的`3`个任务。

实现`promiseAllThrottled `一种方法是使用`Promise.race`来限制给定时间的活动任务数量。

```js
/**
 * Similar to Promise.all but a concurrency limit
 *
 * @param {Array} iterable Array of functions that returns a promise
 * @param {Object} concurrency max number of parallel promises running
 */
function promiseAllThrottled(iterable, { concurrency = 3 } = {}) {
  const promises = [];

  function enqueue(current = 0, queue = []) {
    // return if done
    if (current === iterable.length) { return Promise.resolve(); }
    // take one promise from collection
    const promise = iterable[current];
    const activatedPromise = promise();
    // add promise to the final result array
    promises.push(activatedPromise);
    // add current activated promise to queue and remove it when done
    const autoRemovePromise = activatedPromise.then(() => {
      // remove promise from the queue when done
      return queue.splice(queue.indexOf(autoRemovePromise), 1);
    });
    // add promise to the queue
    queue.push(autoRemovePromise);

    // if queue length >= concurrency, wait for one promise to finish before adding more.
    const readyForMore = queue.length < concurrency ? Promise.resolve() : Promise.race(queue);
    return readyForMore.then(() => enqueue(current + 1, queue));
  }

  return enqueue()
    .then(() => Promise.all(promises));
}
```

`promiseAllThrottled`一对一地处理 Promises 。 它执行`Promises`并将其添加到队列中。 如果队列小于并发限制，它将继续添加到队列中。 达到限制后，我们使用`Promise.race`等待一个承诺完成，因此可以将其替换为新的承诺。 这里的技巧是，promise 自动完成后会自动从队列中删除。 另外，**我们使用 `race` 来检测promise 何时完成，并添加新的 promise 。**



3.Promise 解决的痛点是什么？

1）回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象，是为解决异步操作函数里的嵌套回调（callback hell）问题，代码臃肿，可读性差，只能在回调里处理异常

2）<u>promise可以支持多个并发的请求，获取并发请求中的数据</u>

3）<u>promise可以解决可读性的问题，异步的嵌套带来的可读性的问题，它是由异步的运行机制引起的，这样的代码读起来会非常吃力</u>

4）promise可以解决信任问题，对于回调过早、回调过晚或没有调用和回调次数太少或太多，由于promise只能决议一次，决议值只能有一个，决议之后无法改变，任何then中的回调也只会被调用一次，所以这就保证了Promise可以解决信任问题



4.Promise 在事件循环中的执行过程是怎样的？

1）事件循环

> 从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。由于主线程不断的重复获得消息、执行消息、再取消息、再执行

2）promise的事件循环

> Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环

### 事件模型：

事件模型可以分为三种：

**原始事件模型（DOM0级）**

事件绑定监听函数比较简单, 有两种方式：

1. HTML代码中直接绑定

```html
<input type="button" onclick="fun()">
```



2. 通过JS代码绑定

```js
var btn = document.getElementById('.btn');
btn.onclick = fun;
```



DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行。**只支持冒泡，不支持捕获**。同一个类型的事件只能绑定一次，当希望为同一个元素绑定多个同类型事件的时候是不被允许的，后绑定的事件会覆盖之前的事件。

删除 DOM0 级事件处理程序只要将对应事件属性置为null即可


**标准事件模型（DOM2级）**

在该事件模型中，一次事件共有三个过程:

> 事件捕获阶段：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行
>
> 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数
>
> 事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



1. 事件绑定监听函数的方式如下:

```js
addEventListener(eventType, handler, useCapture)
```



2. 事件移除监听函数的方式如下:

```js
removeEventListener(eventType, handler, useCapture)
```

可以在一个`DOM`元素上绑定多个事件处理器，各自并不会冲突



**IE事件模型（基本不用）**

IE事件模型共有两个过程:

> 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。
>
> 事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



事件绑定监听函数的方式如下:

```js
attachEvent(eventType, handler)
```


事件移除监听函数的方式如下:

```js
detachEvent(eventType, handler)
```



### 事件循环：

#### 浏览器中的事件循环：

> JavaScript 是单线程的语言，所谓单线程无非就是同步队列和异步队列，js代码是自上向下执行的，在主线程中立即执行的就是同步任务，比如简单的逻辑操作及函数，而异步任务不会立马立马执行，会挪步放到到异步队列中，而不同的异步操作添加到任务队列的时机也不同，比如onclick（事件）, setTimeout（计时器）, ajax ，promise处理的方式都不同，总的说就是**等待主线程中任务全部完成后，再回来把异步队列中任务放到主程序中运行，这样反复的循环，就是事件循环。**
>
> 这些异步操作是由浏览器内核来执行的,浏览器内核上包含 3 种 webAPI,分别是 DOM Binding(DOM绑定)、network(网络请求)、timer(定时器)模块

按照这种分类方式:JS 的执行机制是

> 首先判断 js 代码是同步还是异步,不停的检查调用栈中是否有任务需要执行,如果没有,就检查任务队列,从中弹出一个任务,放入栈中,如此往复循环,要是同步就进入主进程,异步就进入事件表
>
> 异步任务在事件表中注册函数,当满足触发条件后,被推入事件队列
>
> 同步任务进入主线程后一直执行,直到主线程空闲时,才会去事件队列中查看是否有可执行的异步任务,如果有就推入主进程中
>
> 以上三步循环执行,这就是事件循环(event loop),它是连接任务队列和控制调用栈的

在一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务）。

**macro-task大概包括：**

> script(整体代码)、setTimeout、setInterval、setImmediate、I/O、UI render

**micro-task大概包括:**

> process.nextTick、Promise、Async/Await(实际就是promise)、MutationObserver(html5新特性)

![img](https://pic4.zhimg.com/v2-0d7af3f483aa991d41dd1f3ba7bac36f_b.webp)

总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

```js
console.log('script start')

async function async1() {
await async2()
console.log('async1 end')
}
async function async2() {
console.log('async2 end')
}
async1()

setTimeout(function() {
console.log('setTimeout')
}, 0)

new Promise(resolve => {
console.log('Promise')
resolve()
})
.then(function() {
console.log('promise1')
})
.then(function() {
console.log('promise2')
})

console.log('script end')
 // 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动
// script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout
```

代码分析：

> 执行代码，输出script start。
>
> 执行async1(),会调用async2(),然后输出async2 end,<u>此时将会保留async1函数的上下文，然后跳出async1函数。</u>
>
> 遇到setTimeout，产生一个宏任务
>
> 执行Promise，输出Promise。遇到then，产生第一个微任务
>
> 继续执行代码，输出script end
>
> 代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，该微任务遇到then，产生一个新的微任务
>
> 执行产生的微任务，输出promise2,当前微任务队列执行完毕。执行权回到async1
>
> 执行await,实际上会产生一个promise返回，即
>
> let promise_ = new Promise((resolve,reject){ resolve(undefined)})
> 执行完成，执行await后面的语句，输出async1 end
>
> 最后，执行下一个宏任务，即执行setTimeout，输出setTimeout
>
> 注意
> **新版的chrome浏览器中不是如上打印的，因为chrome优化了,await变得更快了,输出为:**
>
> ```js
> // script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout
> ```



如果await后面跟的是一个异步函数的调用，比如上面的代码，将代码改成这样：

```js
console.log('script start')

async function async1() {
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2 end')
    return Promise.resolve().then(()=>{
        console.log('async2 end1')
    })
}
async1()

setTimeout(function() {
    console.log('setTimeout')
}, 0)

new Promise(resolve => {
    console.log('Promise')
    resolve()
})
.then(function() {
    console.log('promise1')
})
.then(function() {
    console.log('promise2')
})

console.log('script end')
输出为：

// script start => async2 end => Promise => script end => async2 end1 => promise1 => promise2 => async1 end => setTimeout
```

此时执行完awit并不先把await后面的代码注册到微任务队列中去，而是执行完await之后，直接跳出async1函数，执行其他代码。然后遇到promise的时候，把promise.then注册为微任务。其他代码执行完毕后，需要回到async1函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中，**注意此时微任务队列中是有之前注册的微任务的**。所以这种情况会先执行async1函数之外的微任务(promise1,promise2)，然后才执行async1内注册的微任务(async1 end). 可以理解为，这种情况下，await 后面的代码会在本轮循环的最后被执行。



#### node 中的事件循环：

```js
┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

1. node 的事件循环的阶段顺序为：

   > 输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...
   > 每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。

2. 阶段概述：

  > 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。
  >
  > I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。
  >
  > 闲置阶段(idle, prepare)：仅系统内部使用。
  >
  > 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
  >
  > 检查阶段(check)：setImmediate() 回调函数在这里执行
  >
  > 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。

日常开发中的绝大部分异步任务都是在 poll、check、timers 这3个阶段处理的。



**timers:**

timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。



**poll:**

poll 是一个至关重要的阶段，poll 阶段的执行逻辑流程图如下：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X2pwZy8yd1Y3TGljTDc2Mll4VmlhR3NFbmhSOUtpYmJHNnlRcXBjRWo0VlBGcE9PdnpOYW51S1NnMURvNWVKQlV2SVNvQnNpYVNPN3hTM2liZWpkSGJ6NDhseGRXN3hnLzY0MA?x-oss-process=image/format,png)

> 如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。
>
> 如果没有定时器, 会去看回调函数队列。
>
> 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
>
> 如果 poll 队列为空时，会有两件事发生
>
> 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
>
> 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。



**check:**

check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。



**process.nextTick:**

process.nextTick 是一个独立于 eventLoop 的任务队列。

在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。





#### node 版本差异说明:

<u>*总的变化一句话来说就是，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就会立刻执行对应的微任务队列。*</u>

**timers 阶段的执行时机变化:**

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
```


如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=>promise1=>timer2=>promise2

如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.

如果是第二个定时器还未在完成队列中，最后的结果为timer1=>promise1=>timer2=>promise2

如果是第二个定时器已经在完成队列中，则最后的结果为timer1=>timer2=>promise1=>promise2



**check 阶段的执行时机变化：**

```js
setImmediate(() => console.log('immediate1'));
setImmediate(() => {
    console.log('immediate2')
    Promise.resolve().then(() => console.log('promise resolve'))js
});
setImmediate(() => console.log('immediate3'));
setImmediate(() => console.log('immediate4'));
```


如果是 node11 后的版本，会输出immediate1=>immediate2=>promise resolve=>immediate3=>immediate4

如果是 node11 前的版本，会输出immediate1=>immediate2=>immediate3=>immediate4=>promise resolve



**nextTick 队列的执行时机变化：**

```js
setImmediate(() => console.log('timeout1'));
setImmediate(() => {
    console.log('timeout2')
    process.nextTick(() => console.log('next tick'))
});
setImmediate(() => console.log('timeout3'));
setImmediate(() => console.log('timeout4'));
```


如果是 node11 后的版本，会输出timeout1=>timeout2=>next tick=>timeout3=>timeout4

如果是 node11 前的版本，会输出timeout1=>timeout2=>timeout3=>timeout4=>next tick



#### node 和 浏览器 eventLoop的主要区别：

两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。



#### 了解更多：

[彻底吃透 JavaScript 执行机制](https://juejin.cn/post/6844903955286196237)



### 闭包：

官方的各种定义引用:

> MDN: 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

> 红宝书: 闭包是指有权访问另外一个函数作用域中的变量的函数。

> 现代JavaScript教程: 闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。

**简单来说就是我在写代码时候我们决定了这些变量的访问权限也就是[词法作用域](https://juejin.im/post/6889538437783748621)。然而我们可以用些手段(闭包)如`return` 一个函数。这样即使这个function在当前词法作用域外执行，也能访问原来定义时词法作用域内的变量，（间接地访问了这些变量）。**

```javascript
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz(); // 2       这就是闭包的效果。
```

按照词法作用域来说：`baz`的词法作用域是全局的，外部不能访问foo内部作用域的变量 `a`，但是 `a`确实被正常打印了。而函数 `bar()` 的词法作用域能够访问 `foo()` 的内部作用域。将 `bar` 所引用的函数对象本身当作返回值。 在 `foo()` 执行后， 其返回值(也就是内部的 `bar()`函数) 赋值给变量 `baz` 并调用 `baz()`， 实际上只是通过不同的标识符引用调用了内部的函数 `bar()`。bar() 显然可以被正常执行。

但是在这个例子中，它在自己**定义的词法作用域以外** 的地方执行了。

在 `foo()` 执行后，通常会期待 `foo()` 的整个内部作用域都被销毁，因为我们知道引擎有**垃圾回收机制**用来释放不再使用的内存空间。由于看上去 `foo()` 的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域?原来是 `bar()` 本身在使用。拜 `bar()` 所声明的位置所赐，它拥有涵盖 `foo()` 内部作用域的闭包，使得该作用域能够一直存活，以供 `bar()` 在之后任何时间进行引用。bar() 依然持有对该作用域的引用。

这样做的话一是**可以读取函数内部的变量**，二是**可以让这些变量的值始终保存在内存中**。

**无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。**



```javascript
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
```

正常情况下， 这段代码预期是分别输出数字 1~5， 每秒一次， 每次一个。

但实际上， 这段代码在运行时会以每秒一次的频率输出五次 6。

我们可以利用闭包来解决这个问题。 首先这种IIFE(立即执行函数表达式) 是一個定义完馬上就執行的 JavaScript function，可以创建闭包。

```javascript
for (var i = 1; i <= 5; i++) {
    (function(j) {
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })(i);
}
```

不熟IIFE用`let`也成，本质上这是将一个块转换成一个可以被关闭的作用域。也就是块级作用域。

总的来说闭包就是：

> 当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量,其特点便是：
>
> 1、让外部访问函数内部变量成为可能
>
> 2、局部变量会常驻在内存中
>
> 3、可以避免使用全局变量，防止全局变量污染
>
> 4、会造成内存泄漏（有一块内存空间被长期占用，而不被释放）



### [JS模块化](https://blog.csdn.net/qq_27575925/article/details/113758050)开发规范：

**CommonJS**

- 一个文件一个模块；
- 使用 exports.xx = ... 或者 module.exports ={} 暴露模块；
- 使用 require() 方法引入一个模块；
- require()是同步执行的；

```js
// a.js
let fn=function(msg){
  console.log(msg);
}
exports.outMsg=fn;

//b.js
const a=require('./a.js');
a.outMsg('hello Commonjs'); // hello Commonjs
```

> CommonJS 在NodeJS 环境用，不适用于浏览器；
> 一个文件一个模块；如果有多个导出，则去最后一个导出；

**AMD**

全称 Asynchronous module definition（异步模块定义）

- 使用 define(...) 定义一个模块；
- 使用require(...) 加载一个模块；
- 依赖前置，提前执行；

RequireJS 是AMD 的一种实现

```js
// 模块的定义
/**
*@param id 模块名称，如果为空，模块的名字默认为模块加载器请求的制定脚本名
*@param dependencies 模块依赖
*@param factory 工厂函数，模块初始化执行函数或对象
*/
define(id,dependencies,factory)

// 模块的使用，使用 require 加载模块
require（[module],callback）;
```

**CMD**

全称 Common Module Definition（通用模块定义）

- 一个文件为一个模块
- 使用 define(...) 定义一个模块 （和AMD相似）
- 使用require(...) 加载一个模块（和AMD 相似）

SeaJS 是CMD 的一种实现

```js
// CMD 
define(function(require,exports,module){
  var a=require('./a');
  a.sayHello();
  var b=require('./b');// 依赖就近书写；
  b.sayHello();
  //...
});
```

> CMD和AMD 的最显著的区别 AMD 是提前执行，CMD 是延迟执行，依赖就近；
> AMD： 执行过程中会将所有的依赖模块前置执行，也就是自己的代码逻辑开始前全部执行；
> CMD ：如果require 但整个逻辑未使用这个依赖 或者为执行到逻辑使用它的地方前，不会执行。

**UMD**

全称 Universal Module Definition（万能模块定义），从名字就可以看出 UMD 做的是大一统的工作。Webpack 打包代码就有 UMD 这个选项。

这个万能模块，可以在服务端使用，也可以在浏览器端使用；

它主要做了三件事：

- 判断是否支持AMD
- 判断是否支持CommonJS
- 如果都不支持，使用全局变量

```js
(function (root, factory) {
    // 对应上述的三个步骤
    if (typeof define === 'function' && define.amd) {
        // 1.判断是否支持 AMD
        // 如果 define 这个方法是被定义 并且 define 这个方法是 AMD 的规范，那就把 factory 这个模块实体用 define 方法以 AMD 的规范 定义
        define([], factory); // [] 是依赖，factory 是模块实体
    } else if (typeof exports === 'object') {
        // 2. 判断是否支持 CommonJS
        // 如果 exports 是等于一个对象，则表明是在 Node 环境中运行，则支持 CommonJS，那就用 module.exports 暴露整个模块实体
        module.exports = factory();
    } else {
        // 3. 如果都不支持，使用全局变量
        // Browser globals (root 即是 window)
        root.returnExports = factory();
  }
}(this, function () {
    // Module Defination
    var sum = function(x, y){
        return x + y;
    }
    var sub = function(x, y){
        return x - y;
    }
    var math = {
        findSum: function(a, b){
            return sum(a,b);
        },
        findSub: function(a, b){
            return sub(a, b);
        }
    }
    return math;
}));
```

**ES Module (ES6 模块)**

全称 ECMAScript Module

- 使用 import 导入模块；
- 使用 export 导出模块；

```js
// 导出模块
export var a='123'; //导出变量
export function fn(){}; // 导出函数
export default {name:'p',age:18} // 导出对象； export 不能直接导出对象必须加上default；
export class Myclass{} // 导出类；
```

#### ES6 模块和Common js 模块的差异：

1、CommonJS 输出的是一个值的拷贝；ES6 模块输出的是值的引用；

2、CommonJS 模块是运行时加载；ES6模块是编译时输出接口；

由于ES6 模块是编译时输出接口，所以可以做到 tree shaking；

#### **import 和 require 导入的区别**

import 的ES6 标准模块：是编译时调用，所以必须放在文件开头，是解构过程。

require 是 AMD规范引入方式：是运行时调用，所以require理论上可以运用在代码的任何地方，是赋值过程。

其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量。



## CSS

#### CSS 优先规则

**选择器:**

ID 选择器 (#ID)  Class 选择器 (.class 名)  标签选择器 (标签)  通配符 (*)

相邻选择器 (div+p)   子选择器 (div>p)  后代选择器 (div p)   多个选择器 (div,p,a,ul)

伪类选择器 (a:hover) 

**伪类选择器和伪元素的区别:** 

伪类用于向某些选择器添加特殊效果 (单冒号)

伪元素用于将某个特殊的东西添加到某些元素的前后 (双冒号)

> 优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器

**::after/:after 与::before/:before 的区别** 

:before 在元素之前添加效果/:after 是在元素之后添加效果;

:after/:before 是 CSS2 提出的,兼容 IE8;

::after/::before 是 CSS3 为了区分伪类和伪元素的做出的差 别,为了避免兼容性问题,习惯性的还是写:after/:before; 

可继承样式: font-size/fon-family/color 

不可继承样式:width/height/margin/padding/border

#### CSS定义的权重

> 1就近原则,后加样式优于前面的样式 
>
> 2内嵌样式>内联样式>外联样式 
>
> 3 !Important 大于一切样式

```css
// 以下是权重的规则：继承的样式没有权值,标签类型选择器和伪元素 :div/p的权重为1，class/伪类/属性选择器的权重为10，id的权重为100，内联样式:style=””为1000,以下/// 例子是演示各种定义的权重值：

/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
}

// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现
```

#### CSS 单位 px、em、rem、rpx、vh、vw 的解释比较

>1. px也就是像素，第一印象它是绝对长度，是定死的，所以想要响应式布局和自适应布局不要用它。但其实”绝对“，”定死“这些并不准确，它的大小也是会随着屏幕变化的。
>2. rem使用更方便且用途更普遍，所以我们先来看rem。非常简单，设定根元素<html>的font-size属性，默认为16px，那么1rem = 16px。设置为20px，那么1rem = 20px。为了简化计算，我们想令1rem = 10px，就设定根元素font-size为10px或者62.5%（16*62.5%=10）。用 rem 有什么好处？可以实现响应式布局了！响应式布局指的是元素大小能根据屏幕大小随时变化，因为 rem 布局里所有大小跟着根元素变化，所以只要在屏幕大小变化的时候改变根元素font-size就行了。
>3. rpx是微信小程序为了解决自适应屏幕尺寸设计的单位，它规定任何屏幕的宽都是750rpx。vw是css3新出的单位，规定任何屏幕宽都是100vw，高100vh，就是是将窗口大小平分为 100 份;这里的屏幕指的是视口，即浏览器窗口，不受分辨率和dpr影响，还是很方便的。

#### [Flex布局](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

![flex-容器属性](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-container.jpg)

![flex-项目属性](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-project.jpg)



#### 盒子水平垂直居中的五种方法：

相对定位： 先让子盒子的左上角居中然后在向左和向上移动子盒子的宽和高的一半。缺点是需要知道子盒子具体的宽和高

```css
top: 50%;
left: 50%;
margin-left: -25px;
margin-top: - 25px;
```

绝对定位：设置子盒子的上、下、左、右都为0，然后再用margin: auto;来设置居中。不需要知道盒子具体的宽和高，但必须要有固定的宽和高。

```css
top: 0;
left: 0;
right: 0;
bottom: 0;
margin: auto;
```

相对定位+CSS3的translate：同一，先让盒子的左上角居中（left，top 50%），然后再借助translate让子盒子分别向左和向上移动盒子的一半。不需要知道盒子具体的宽和高，但不是所有浏览器都兼容。

```css
top: 50%;
left: 50%;
transform: translate(-50% -50%);
```

display: flex：利用flex布局让子盒子居中，同样也存在兼容性问题

```css
 #box{
    width:100%;
  height:100%;
  background:#eee;
  display:flex;
  justify-content: center;
  align-items: center;
}
```

利用JavaScript，获取分别获取大盒子和子盒子的宽和高，然后再通过计算让子盒子居中

#### 两边固定 中间自适应 （圣杯布局和双飞翼布局）

**圣杯布局结构**： 

> main是中间部分 必须放在文档流的最起前边 优先渲染
>
> 好处：重要的内容放在文档流前面可以优先渲染
>
> 原理：利用相对定位、浮动、负边距布局，而不添加额外标签

- 

```html
<div class="contaer">
        <div class="main"></div>
        <div class="left"></div>
        <div class="right"></div>
</div>
.contaer {
    /*3， 给父盒子添加padding  把main挤过来 */
    padding: 0 200px;
}
        
.left,
.right {
    width: 200px;
    height: 200px;
    background-color: red;
    /*1， 给左右盒子添加左浮动 */
    float: left;
    /* 4，给左右盒子添加相对于自己的定位 */
    position: relative;
}
        
.left {
    /*2， 让盒子上去 */
    margin-left: -100%;
    /* 让盒子定位在左边 */
    left: -200px;
}
.right {
    /* 2，让盒子上去 */
    margin-left: -200px;
    /*4. 让盒子定位在右边 */
    right: -200px;
}
        
.main {
    width: 100%;
    height: 200px;
    background-color: blueviolet;
    float: left;
    text-align: center;
}
```

> 1，给左中右设置左浮动 但是 mian部分的宽度为100% 所以左右元素不会上去
>
> 2，给left 一个margin-left = -100% right 的margin-left : -200px (这里是right盒子的宽度)
>
> 3，这时由于main的左右部分被挡住 只好给contaer padding值把main挤出来
>
> 4，这样做之后左右盒子也被挤过来了 所以需要给两个盒子添加定位 相对于自己 把盒子定在左右两边


也可以通过flex布局：

```css
.contaer {
    /* 给父盒子设置flex */
    display: flex;
}

.main {
    /* 中间部分  丰乐乡：1  让盒子占据剩下的所有剩余空间 */
    flex: 1;
    height: 200px;
    background-color: blueviolet;
}

.left,
.right {
    width: 200px;
    height: 200px;
    background-color: red;
}

.left {
    /* 让左侧盒子放在前边  但不是最先渲染 */css
    order: -1;
}
```

**双飞翼布局**：

> 去掉了圣杯布局中的定位和padding 但是需要在main加入一个p标签 后给p标签margin。对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局
>
> 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。

结构：

```html
<div class="contaer">
        <div class="main">
            <p>main</p>
        </div>
        <div class="left">left</div>
        <div class="right">right</div>
</div>
```


样式：

```css
.left,
.right {
    width: 200px;
    height: 200px;
    background-color: red;
    /* 给左右盒子添加左浮动 */
    float: left;
}
.left {
    /* 让盒子上去 */
    margin-left: -100%;
    
}
.right {
    /* 让盒子上去 */
    margin-left: -200px;
    
}
.main {
    width: 100%;
    height: 200px;
    background-color: blueviolet;
    float: left;
}
/* 给p添加margin*/
p {
    margin: 0 200px;
}
```


**双飞翼布局和圣杯布局的区别**：

> 除了结构上的差别 圣杯布局中 当页面很小的时候 main 会被挤下来 但是双飞翼布局不会 flex布局也不会

#### 创建一个三角形的原理

```css
#demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```

#### 清除浮动的方式

1.在子元素并级后面添加一个新元素，添加 clear：both 属性 

优点：通俗易懂，容易掌握   缺点：添加无意义空标签，不方便后期维护 

2.给父元素添加 overflow:hidden 

优点：代码较少，简单方便   缺点：不能配合定位使用 

3.：after 方法（作用于浮动元素的父元素）

```css
.clearfix:after{
  content:"";
  display: block;
  height:0;
  clear:both;
  visibility:hidden;
}
/* 为兼容 IE6,IE7，因为 ie6,ie7 不能用 after 伪类 */
.clearfix{
  zoom:1;
}
```

优点：结构和语义化完全正确   缺点：复用方式不当，会造成代码量增加



**CSS 实现单行文本溢出显示** 

```css
overflow : hidden ; 
text-overflow : ellipsis ; 
white-space : nowrap ;
```

还需要加宽度 width 属性来兼容部分浏览器 

**实现多行文本溢出显示**

```css
display : -wedkit-box ; 
-webkit-box-orient : vertical ; 
-webkit-line-clamp : 3 ; 
overflow : hidden ;
```

适用范围 : 因使用了 Webkit 的 CSS 扩展属性,该方法适用于 Webkit 浏览器 以及移动端 注: 

 -webkit-line-clamp 用来限制在一个块元素显示的文本的行数,为了实现 该效果,它需要组合其它的 webkit 属性。 

 常见结合属性： 

 display：-webkit-box； 必须结合的属性，将对象作为弹性伸缩盒 子模式显示。 

 -webkit-box-orient 必须结合的属性，设置或减缩伸缩盒对象的子 元素排列方式。 **溢出显示的另外一种显示方式** 

实现方式：

```css
div{ 
  position：relative； 
  line-height：20px； 
  max-height：40px； 
  overflow：hidden； 
} 
div：after{ 
  content : “...”; 
  position : absolute ; 
  bottom : 0 ; 
  right : 0 ; 
  padding-left : 40px ;  
  background : -webkit-linear-gradient(left , transparent , #fff 55%); 
  background : -o-linear-gradient(left , transparent , #fff 55%);   background : -moz-linear-gradient(left , transparent , #fff 55%);
    background : linear-gradient(left , transparent , #fff 55%); 
} 
```

此方法也有弊端：就是未超出行的情况下也会出现省略号 

注:

1. 将 height 设置为 line-height 的整数倍,防止超出的文字露出。
2. 给 p::after 添加渐变背景可避免文字只显示一半。 
3. 由于 ie6-7 不显示 content 内容，所以要添加标签兼容 ie6-7，兼容 ie8 需要将 ：：after 替换成 ：after



## React

> 类组件可以使用其他特性，如状态 state 和生命周期钩子。
>
> 当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。
>
> 函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。




## TypeScript

> Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。

### Typescript的优缺点：

> **优点：**
>
> 1：快速简单，易于学习。
>
> 2：编译时提供错误检查， 在代码运行前就会进行错误提示。
>
> 3：支持所有的JS库。
>
> 4：支持ES6，提供了ES6所有优点和更高的生产力。
>
> 5：使用继承提供可重用性。
>
> 6：有助于代码结构。
>
> 7：通过定义模块来定义命名空间。
>
> **缺点：**
>
> 1：需要长时间的来编译代码。
>
> 2：在使用第三方库时，需要有三方库的定义文件，并不是所有三方库都提供了定义文件，提供的定义文件是否准确也值得商榷。

### Ts中的类型层级

在TypeScript（Ts）中，类型系统是非常强大和灵活的。类型层级（Type Hierarchy）通常指的是类型之间的继承、交叉、联合、条件等关系，这些关系共同构成了TypeScript的类型结构。虽然TypeScript没有一个显式的“类型层级”结构图，但我们可以理解一些主要的概念和它们之间的关系。

以下是TypeScript中类型层级的一些关键概念：

> 
>
> 1. 基础类型（Basic Types）
>    - 包括`number`、`string`、`boolean`、`symbol`、`undefined`、`null`、`void`、`any`、`unknown`、`never`和`object`。
>    - 这些是最基本的类型，它们构成了TypeScript类型系统的基石。
> 2. 字面量类型（Literal Types）
>    - 允许你指定变量只能是某个特定的值，如`let x: 42;`。
> 3. 数组和元组（Arrays and Tuples）
>    - 数组类型表示一组相同类型的值的集合，如`let arr: number[] = [1, 2, 3];`。
>    - 元组类型允许你表示一个已知元素数量和类型的数组，如`let tuple: [string, number] = ['hello', 42];`。
> 4. 枚举类型（Enum Types）
>    - 枚举类型是一种特殊的数值类型，它允许你为一组命名的数值常量赋予有意义的名称。
> 5. 类类型（Class Types）
>    - 类是TypeScript面向对象编程的基础，它们有自己的属性和方法。
>    - 你可以通过`new`关键字创建类的实例，并访问其属性和方法。
> 6. 接口（Interfaces）
>    - 接口是TypeScript中定义对象形状的一种方式。
>    - 它们可以描述对象应该有哪些属性和方法，但不包含这些属性或方法的实现。
> 7. 类型别名（Type Aliases）
>    - 类型别名是给一个类型起的新名字。
>    - 它们有助于简化复杂的类型签名，并提高代码的可读性。
> 8. 交叉类型（Intersection Types）
>    - 交叉类型是将多个类型合并为一个类型。
>    - 这允许一个值同时具有多个类型的特性。
> 9. 联合类型（Union Types）
>    - 联合类型表示一个值可以是几种类型之一。
>    - 这在处理多种可能类型的值时非常有用。
> 10. 条件类型（Conditional Types）
>     - 条件类型允许你基于条件来选择不同的类型。
>     - 这在编写泛型代码时特别有用，可以根据输入参数的类型来返回不同的类型。
> 11. 泛型（Generics）
>     - 泛型允许你编写灵活、可重用的代码，这些代码可以处理多种数据类型。
>     - 泛型通过类型参数来定义，这些参数可以在函数、接口和类中使用。
> 12. 索引类型（Index Types）
>     - 索引类型用于描述具有索引签名的对象，这些对象允许你使用字符串或数字作为键来访问其属性。
> 13. 映射类型（Mapped Types）
>     - 映射类型是基于另一个类型生成的新类型。
>     - 它们对于根据现有类型创建新类型（例如，添加或修改属性）非常有用。
> 14. 类型守卫（Type Guards）
>     - 类型守卫是一种表达式，它执行一些运行时检查，并返回一个类型断言。
>     - 类型守卫有助于缩小联合类型的范围，并在运行时确定值的实际类型。

这些概念共同构成了TypeScript的类型层级，使你能够构建复杂、类型安全的代码库。

### Ts中内置的工具类型

在TypeScript（Ts）中，内置的工具类型提供了一些对类型进行操作的便捷方式，从而能够创建更复杂的类型或简化类型定义。以下是一些常用的内置工具类型：

1. Partial<T>

   - 这个工具类型将类型的所有属性都变为可选的。换句话说，它接受一个类型`T`，并返回一个新的类型，其中`T`的所有属性都变成了可选属性。

   - 示例：

     ```typescript
     interface Person {  
       name: string;  
       age: number;  
     }  
      
     type PartialPerson = Partial<Person>;  
     // 相当于  
     type PartialPerson = {  
       name?: string;  
       age?: number;  
     };
     ```

2. Required<T>

   - 与`Partial`相反，`Required`工具类型将类型的所有属性都变为必选的。

   - 示例：

     ```typescript
     type RequiredPerson = Required<PartialPerson>;  
     // 相当于  
     type RequiredPerson = {  
       name: string;  
       age: number;  
     };
     ```

3. Readonly<T>

   - 这个工具类型将类型的所有属性都设置为只读，意味着这些属性只能被读取，不能被重新赋值。

   - 示例：

     ```typescript
     type ReadonlyPerson = Readonly<Person>;  
     // 相当于  
     type ReadonlyPerson = {  
       readonly name: string;  
       readonly age: number;  
     };
     ```

4. Pick<T, K extends keyof T>

   - `Pick`工具类型从类型`T`中挑选出一组属性`K`来构造一个新的类型。

   - 示例：

     ```typescript
     type NameOnly = Pick<Person, 'name'>;  
     // 相当于  
     type NameOnly = {  
       name: string;  
     };
     ```

5. Omit<T, K extends keyof T>

   - 与`Pick`相反，`Omit`工具类型从类型`T`中排除一组属性`K`来构造一个新的类型。

   - 示例：

     ```typescript
     type AgeOnly = Omit<Person, 'name'>;  
     // 相当于  
     type AgeOnly = {  
       age: number;  
     };
     ```

6. Record<K extends keyof any, T>

   - `Record`工具类型用于构造一个对象的类型，该对象的属性键是`K`中的类型，属性值是`T`类型。

   - 示例：

     ```typescript
     type NameMapping = Record<string, number>;  
     // 相当于  
     // {  
     //   [key: string]: number;  
     // }
     ```

7. Exclude<T, U>

   - 这个工具类型从类型`T`中排除所有可以赋值给类型`U`的属性或值，返回一个新的类型。

   - 示例：

     ```typescript
     typescript复制代码
     
     type T0 = Exclude<"a" | "b" | "c", "a">;  // "b" | "c"
     ```

8. Extract<T, U>

   - 与`Exclude`相反，`Extract`工具类型从类型`T`中提取所有可以赋值给类型`U`的属性或值，返回一个新的类型。

   - 示例：

     ```typescript
     typescript复制代码
     
     type T0 = Extract<"a" | "b" | "c", "a" | "f">;  // "a"
     ```

9. NonNullable<T>

   - 这个工具类型从类型`T`中排除`null`和`undefined`，返回一个新的类型。

   - 示例：

     ```typescript
     typescript复制代码
     
     type T0 = NonNullable<string | number | undefined>;  // string | number
     ```

这些工具类型在TypeScript的类型编程中非常有用，可以帮助你创建更复杂、更灵活的类型定义。

### Ts中常用的自定义工具类型

在TypeScript（Ts）中，除了内置的工具类型，开发人员也经常根据项目的特殊需求定义自定义工具类型。这些自定义工具类型可以根据项目的具体需求来创建，以简化代码和提高工作效率。

虽然没有一个固定的“常用”自定义工具类型列表，但以下是一些可能的示例和概念，这些示例和概念可以作为创建自定义工具类型的灵感：

> 
>
> 1. 自定义的“选择”类型（Pick-like types）
>    - 与内置的`Pick`类型类似，但可能具有额外的逻辑或功能。例如，你可能想要创建一个类型，该类型不仅从原始类型中选择属性，还对这些属性进行某种转换或验证。
> 2. 自定义的“排除”类型（Omit-like types）
>    - 与内置的`Omit`类型类似，但提供了更多的灵活性。例如，你可能想要排除所有具有特定类型或满足特定条件的属性。
> 3. 类型映射（Type Mapping）
>    - 使用映射类型（Mapped Types）和条件类型（Conditional Types）来创建新的类型，这些类型基于原始类型的每个属性进行某种转换或操作。例如，你可能想要创建一个类型，该类型将原始类型中的所有字符串属性转换为大写。
> 4. 类型合并（Type Merging）
>    - 创建一个自定义工具类型，用于合并两个或多个类型的属性。这可以通过扩展类型、交叉类型（Intersection Types）或其他技术来实现。
> 5. 类型守卫的扩展（Extended Type Guards）
>    - 自定义类型守卫可以用于在运行时确定值的实际类型，并返回更具体的类型信息。你可以创建自定义的类型守卫来处理特定于你项目的类型或逻辑。
> 6. 特定于领域的类型（Domain-specific types）
>    - 对于特定的业务领域或应用场景，可能需要定义一些自定义的工具类型来更好地表示和操作数据。例如，在处理日期、时间、货币或其他复杂数据类型时，可能需要定义特定的自定义类型。
> 7. 自定义的实用程序类型（Utility types）
>    - 创建一些实用的自定义类型，用于简化常见的类型操作或转换。这些类型可能类似于内置的实用程序类型（如`Partial`、`Required`等），但提供了更具体的功能或更适用于你的项目。

请注意，以上示例仅作为创建自定义工具类型的灵感来源，并不是必须遵循的规范。在实际项目中，你应该根据项目的具体需求和约束来定义自定义工具类型。

### Ts中的类型推断、类型断言、非空断言

在TypeScript（Ts）中，类型推断、类型断言和非空断言是处理类型系统时非常重要的概念。下面我将分别解释这三个概念：

**1. 类型推断（Type Inference）**

类型推断是TypeScript编译器自动推断变量或表达式类型的机制。当你声明一个变量并给它赋值时，TypeScript会根据这个值来推断出变量的类型，而不需要显式地指定。

例如：

```typescript
let age = 30; // 编译器推断 age 的类型为 number  
let name = "Alice"; // 编译器推断 name 的类型为 string
```

在上面的例子中，`age` 的类型被推断为 `number`，而 `name` 的类型被推断为 `string`。

**2. 类型断言（Type Assertion）**

类型断言是一种显式地告诉TypeScript编译器某个值或表达式的类型是什么的方式。当TypeScript编译器无法推断出某个值或表达式的类型，或者当你知道某个值或表达式的类型比编译器推断的更具体时，你可以使用类型断言。

类型断言有两种语法：

- **尖括号语法**：`<Type>value`
- **as 关键字**：`value as Type`（推荐在JSX或`tsconfig.json`中配置了`"jsx": "react"`时使用）

例如：

```typescript
let someValue = "42";  
let num = <number>someValue; // 使用尖括号语法进行类型断言  
// 或者  
let num2 = someValue as number; // 使用as关键字进行类型断言
```

注意：类型断言是告诉编译器“相信我，我知道这个值的类型”，因此应谨慎使用，因为它可能会导致运行时错误。

**3. 非空断言（Non-null Assertion Operator）**

非空断言运算符 `!` 是一个后缀表达式运算符，用于告诉TypeScript编译器某个值不是 `null` 或 `undefined`。这在你确定某个值不可能是 `null` 或 `undefined`，但TypeScript编译器无法确定时特别有用。

例如：

```typescript
let obj: { prop?: string } = { prop: "Hello" };  
console.log(obj.prop!.toUpperCase()); // 使用非空断言确保 prop 存在
```

在上面的例子中，即使 `prop` 属性是可选的，但我们确信在这个特定的上下文中 `prop` 一定是存在的，因此我们使用非空断言 `!` 来告诉TypeScript编译器这一点。

同样地，非空断言也应该谨慎使用，因为它会绕过TypeScript的 `null` 和 `undefined` 检查，可能导致运行时错误。在使用非空断言之前，请确保你完全确定该值不会是 `null` 或 `undefined`。

#### Ts中type和interface的区别

在 TypeScript（Ts）中，`type` 和 `interface` 都是用于定义类型别名的机制，但它们之间有一些关键的区别和使用场景。以下是 `type` 和 `interface` 之间的主要区别：

**1. 语法和扩展性**

- **interface** 使用关键字 `interface` 定义，并且可以通过 `extends` 关键字进行扩展。
- **type** 使用关键字 `type` 定义，可以使用交叉类型（`&`）来组合多个类型。

**示例：**

```typescript
// 使用 interface 扩展  
interface Animal {  
    name: string;  
}  
  
interface Dog extends Animal {  
    breed: string;  
}  
  
// 使用 type 交叉类型  
type Named = {  
    name: string;  
};  
  
type Dog = Named & {  
    breed: string;  
};
```

**2. 可声明成员**

- **interface** 可以声明属性、方法、索引签名和另一个接口。
- **type** 除了可以声明与 `interface` 相同的成员外，还可以声明基本类型、字面量类型、元组、联合类型和交叉类型。

**示例：**

```typescript
// 使用 interface 声明属性和方法  
interface Circle {  
    radius: number;  
    area(): number;  
}  
  
// 使用 type 声明字面量类型和联合类型  
type Status = 'success' | 'failure' | 'pending';  
  
// 使用 type 声明元组  
type Pair<T> = [T, T];  
  
// 使用 type 声明交叉类型（已在前面示例中展示）
```

**3. 使用场景**

- **interface** 通常用于定义对象的形状，特别是在面向对象编程中定义类的契约。
- **type** 更通用，可以用于定义任何类型别名，包括基本类型、复杂类型以及组合类型。

**4. 互操作性**

- 在某些情况下，`type` 和 `interface` 可以互换使用，但它们的互操作性受到一些限制。例如，你不能在类类型上直接实现一个 `type`，但可以实现一个 `interface`。

**5. 默认值**

- **interface** 不能为属性提供默认值。
- **type** 可以使用字面量类型来提供属性的默认值，但这并不是传统意义上的“默认值”，而是表示该属性只能是特定的值之一。

**6. 兼容性**

- 当两个 `interface` 合并时（例如，在不同的文件中声明了同一个 `interface`），它们会被合并成一个类型。
- 对于 `type`，当两个具有相同名称的 `type` 声明出现在不同的作用域中时，它们会被视为不同的类型，这可能会导致编译错误。

**7. 泛型**

- **interface** 可以声明泛型接口。
- **type` 也可以声明泛型类型别名。

**示例：**

```typescript
// 使用 interface 声明泛型接口  
interface List<T> {  
    data: T[];  
}  
  
// 使用 type 声明泛型类型别名  
type ListType<T> = {  
    data: T[];  
};
```

在选择使用 `type` 还是 `interface` 时，应根据具体的使用场景和需求来决定。在大多数情况下，两者都可以实现相同的功能，但它们的语法和特性有所不同。



### Ts中的any、unkonwn、never

在TypeScript（Ts）中，`any`、`unknown` 和 `never` 是三个特殊的类型，它们用于处理类型系统中的某些边缘情况或不确定性。

**1. `any`**

`any` 类型是一个特殊的类型，表示“任何类型”。当你不知道一个变量或表达式确切的类型时，你可以将其类型设置为 `any`。将一个值设置为 `any` 类型后，你可以在这个值上调用任何方法或访问任何属性，而不会收到编译错误。然而，这也意味着你失去了TypeScript提供的类型检查的好处，所以应该尽量避免过度使用 `any` 类型。

示例：

```typescript
let x: any = 42;  
x.someNonExistentMethod(); // 不会编译错误，因为 x 是 any 类型
```

**2. `unknown`**

`unknown` 类型是一个安全的、顶级的、未知的类型。与 `any` 不同，`unknown` 类型的变量允许你进行某些操作（如赋值给 `any` 类型的变量或进行类型断言），但在你明确知道它的实际类型之前，你不能在其上调用任何方法或访问任何属性。这使得 `unknown` 类型比 `any` 类型更安全，因为它强制你进行显式的类型检查。

示例：

```typescript
let y: unknown = getSomeValue(); // 假设 getSomeValue 返回 unknown 类型的值  
// y.someMethod(); // 错误：因为 y 是 unknown 类型，不能直接调用方法  
  
if (typeof y === 'string') {  
    console.log(y.toUpperCase()); // 现在可以，因为我们确定了 y 是 string 类型  
}
```

**3. `never`**

`never` 类型表示的是那些永不存在的值的类型。`never` 类型是所有类型的子类型，也可以看作是一个空的类型集。它通常用于表示函数永远不会返回（例如，函数总是抛出错误或进入无限循环），或者用于表示一个变量永远不会被赋值（例如，一个总是抛出错误的函数中的局部变量）。

示例：

```typescript
function error(message: string): never {  
    throw new Error(message);  
}  
  
// 变量 x 被赋值为一个 never 类型的表达式  
// 但是，由于 never 类型没有值，所以 x 在这里实际上是没有意义的  
let x: never = error("Something went wrong"); // 这会抛出错误，但 x 的类型仍然是 never  
  
// 另一个示例：一个总是返回 false 的函数返回类型为 never  
function alwaysFalse(): never {  
    return false as never; // 使用类型断言将 false 转换为 never 类型  
}
```

注意：在实际编程中，你很少会显式地声明一个变量为 `never` 类型，但 `never` 类型在 TypeScript 的类型系统中是一个重要的概念，用于处理那些不可能发生的情况。

#### 说说对 TypeScript 装饰器的理解？

TypeScript 装饰器（Decorators）是一种特殊类型的声明，它可以被附加到类声明、方法、属性或参数上。装饰器使用 `@expression` 的形式，其中 `expression` 必须求值为一个函数，该函数将在运行时被调用，用来修改类的行为。

装饰器在 TypeScript 和 Angular 框架中特别常见，尤其是在 Angular 的组件、服务、指令等中。它们提供了一种声明式的方式来修改类的行为或属性，而无需修改类的代码。

以下是装饰器的一些关键点和用法：

1. **类型**：装饰器可以是类装饰器、方法装饰器、属性装饰器或参数装饰器。

   - 类装饰器：应用于类声明。
   - 方法装饰器：应用于类的方法。
   - 属性装饰器：应用于类的属性。
   - 参数装饰器：应用于方法的参数。

2. **语法**：装饰器使用 `@` 符号，后面跟着一个函数表达式。

   ```typescript
   function classDecorator(constructor: Function) {  
     // ...  
   }  
    
   @classDecorator  
   class MyClass {  
     // ...  
   }
   ```

3. **参数**：

   - 类装饰器接收一个参数，即类的构造函数。
   - 方法装饰器接收三个参数：类的原型、方法名、以及方法的描述符（一个对象，包含 `value`、`writable`、`enumerable` 和 `configurable` 属性）。
   - 属性装饰器接收两个参数：类的原型和属性名。
   - 参数装饰器接收三个参数：类的原型、方法名（或访问器名）以及参数索引。

4. **用途**：

   - 日志和调试：可以记录类的实例化、方法的调用等。
   - 依赖注入：在 Angular 中，装饰器用于自动注入服务。
   - 权限控制：可以在方法或属性上添加访问权限检查。
   - 修改或扩展类的功能：可以在运行时修改类的行为或添加新的方法。

5. **注意事项**：

   - 装饰器是实验性的特性，尽管在 TypeScript 中已经稳定，但在某些 JavaScript 环境中可能不受支持。
   - 装饰器在编译时会被转换为函数调用，并附加到类的构造函数或方法上。
   - 由于装饰器是在运行时被调用的，所以它们可能影响性能，特别是在大型应用程序中。

6. **与注解（Annotations）的区别**：在 Java 和其他某些语言中，注解和装饰器是类似的概念，但在 TypeScript 中，它们没有区别。装饰器就是 TypeScript 实现的注解功能。

最后，要注意的是，装饰器在 TypeScript 中是一个高级特性，通常用于框架或库的开发中。在简单的应用程序中，可能不需要使用装饰器。但在复杂的项目中，它们可以极大地提高代码的可读性和可维护性。



### TypeScript 的泛型

TypeScript 的泛型（Generics）是一种在定义函数、接口或类时，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。泛型允许我们编写灵活、可复用的代码，而不需要为每种数据类型都编写一遍。

**泛型的基本使用**

在 TypeScript 中，我们可以使用 `T`（或其他任何大写字母）来表示泛型类型。例如，我们可以定义一个泛型函数：

```typescript
function identity<T>(arg: T): T {  
    return arg;  
}
```

在这个例子中，`T` 是一个类型变量，它表示我们要传入的参数类型，同时也是返回值的类型。当我们调用这个函数时，我们可以传入任何类型的参数，函数会返回同类型的值：

```typescript
let output = identity<string>("myString");  // 输出为 "myString"  
let numOutput = identity<number>(123);  // 输出为 123
```

**泛型在接口和类中的使用**

泛型也可以用于定义接口和类。例如，我们可以定义一个泛型接口：

```typescript
interface GenericIdentityFn<T> {  
    (arg: T): T;  
}  
  
function identityFn<T>(arg: T): T {  
    return arg;  
}  
  
let myIdentity: GenericIdentityFn<number> = identityFn;
```

在这个例子中，我们定义了一个泛型接口 `GenericIdentityFn`，它接受一个类型为 `T` 的参数，并返回一个类型为 `T` 的值。然后我们定义了一个函数 `identityFn`，它的类型与 `GenericIdentityFn<T>` 匹配，并指定了 `T` 为 `number` 类型。

**泛型约束**

有时我们可能希望对泛型进行约束，以确保它至少具有某些属性或方法。这时，我们可以使用 `extends` 关键字来定义泛型约束：

```typescript
interface Lengthwise {  
    length: number;  
}  
  
function loggingIdentity<T extends Lengthwise>(arg: T): T {  
    console.log(arg.length);  // 现在我们可以访问arg.length了  
    return arg;  
}
```

在这个例子中，我们定义了一个泛型接口 `Lengthwise`，它要求任何实现该接口的类型都必须具有一个 `length` 属性。然后我们在 `loggingIdentity` 函数中使用了泛型约束 `T extends Lengthwise`，这意味着 `T` 必须是实现了 `Lengthwise` 接口的类型。因此，在这个函数中，我们可以安全地访问 `arg.length`。

以上就是对 TypeScript 泛型的基本介绍。泛型是 TypeScript 中非常强大和实用的特性之一，它允许我们编写更加灵活和可复用的代码。

相关[试题](https://www.jianshu.com/p/c8aaba6e8ce0)


## Canvas

### 渲染Canvas底层原理

Canvas的渲染底层原理主要涉及HTML5中的Canvas API和图形渲染上下文（Graphics Context）。以下是Canvas渲染的底层原理的简要概述：

> 1. **创建Canvas元素**：首先，在HTML文档中创建一个`<canvas>`元素。这个元素本身并不直接显示任何内容，而是作为一个容器，用于承载后续的图形绘制。
> 2. **图形渲染上下文**：当`<canvas>`元素被创建后，浏览器会为其创建一个图形渲染上下文（Graphics Context）。这个上下文是一个接口，提供了一系列的绘图API，允许开发者在`<canvas>`元素上进行各种绘图操作。
> 3. **使用Canvas API绘图**：通过JavaScript代码，我们可以访问`<canvas>`元素的图形渲染上下文，并使用Canvas API进行绘图。这些API包括绘制线条、填充颜色、绘制图形（如圆形、矩形等）、绘制文本等。
> 4. **像素渲染**：在绘图过程中，Canvas会将绘制的图形转换成像素数据。这个过程通常是由GPU（图形处理器）来完成的，GPU能够高效地处理大量的像素数据，从而实现流畅的图形渲染。
> 5. **屏幕显示**：最后，Canvas将处理好的像素数据渲染到屏幕上，形成最终的图形显示。这个过程是由操作系统和浏览器共同完成的，它们负责将GPU输出的像素数据呈现在屏幕上。

需要注意的是，Canvas的渲染性能受到多种因素的影响，包括设备的性能、浏览器的实现方式、绘图的复杂度等。因此，在使用Canvas进行图形渲染时，需要注意优化代码和算法，以提高渲染性能。

此外，还有一些技术可以用于优化Canvas的渲染性能，例如使用离屏Canvas（OffscreenCanvas）进行预渲染、使用Web Workers进行多线程渲染等。这些技术可以进一步提高Canvas的渲染效率和性能。



### canvas 与 svg 的区别

Canvas和SVG在网页图形渲染方面都有各自的优势和适用场景，它们之间存在一些显著的区别。

1. 图片格式与绘制方式：

   > - Canvas是通过JavaScript在内存中绘制图像，然后通过浏览器将其呈现在屏幕上。绘制的图形是位图，即像素图，依赖于分辨率，能以.png和.jpg等格式保存存储图像。
   > - SVG则是基于XML的矢量图像格式，使用矢量图像技术绘制图形。这意味着SVG图像可以任意缩放而不失真，适用于各种屏幕和打印分辨率。

1. 事件处理与交互性：

> - Canvas不支持事件处理器，即不能直接在绘制的图形上绑定事件。但是，可以通过监听整个Canvas元素的事件，并使用坐标判断来确定用户点击的是哪个图形。
> - SVG支持事件处理器，可以在SVG元素上绑定事件，如鼠标点击、鼠标移动等，实现更丰富的交互效果。

1. 动画与动态效果：

> - Canvas和SVG都支持创建各种动画效果。Canvas通过JavaScript控制图形的位置、大小和颜色等属性来实现动态效果。而SVG也可以通过JavaScript来改变SVG元素的属性，实现动态交互效果。

1. 跨平台兼容性：

> - Canvas和SVG都是基于Web标准的技术，可以在各种现代浏览器上运行，而不需要额外的插件或软件。这使得它们成为开发跨平台应用的理想选择。

1. 可扩展性与灵活性：

> - Canvas提供了丰富的扩展功能，开发者可以通过自定义绘图算法和渲染引擎来实现更高级的图形效果。同时，Canvas还支持与其他Web技术的无缝集成，如CSS和JavaScript，使开发更加灵活和强大。
> - SVG同样具有可扩展性，因为它是基于XML的，可以很容易地与其他XML技术集成。此外，SVG还支持使用CSS样式进行美化，实现更丰富的视觉效果。

2. 适用范围：

> - 由于Canvas是逐像素进行渲染的，一旦图形绘制完成，就不会继续被浏览器关注。因此，Canvas适合有许多对象要被频繁重绘的图形密集型应用，如游戏。
> - SVG是通过DOM操作来显示的，因此更适合带有大型渲染区域的应用程序，如地图。此外，SVG还适合需要高度交互性和可缩放性的应用。

综上所述，Canvas和SVG在图片格式、事件处理、动画效果、跨平台兼容性、可扩展性和适用范围等方面都存在明显的区别。在选择使用哪种技术时，需要根据具体的应用需求和场景进行权衡和选择。




## 浏览器相关

### Http缓存：

> http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。
>
> http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

![http-cache-2](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-2.jpg)

#### 1、http缓存的分类：

 根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) 强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。

**强制缓存**
强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。

![http缓存-强制](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-force-cache.jpg)

**协商缓存**
当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现

![http缓存-协商](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-negotiation-cache.jpg)

#### 2、如何使用HTTP缓存 ？

一般需要缓存的资源有html页面和其他静态资源：
**html页面缓存的设置主要是在标签中嵌入标签，这种方式只对页面有效，对页面上的资源无效,静态资源的缓存一般是在web服务器上配置的**

1. html页面禁用缓存的设置如下：

```html
<meta http-equiv="pragma" content="no-cache">
// 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求
<meta http-equiv="cache-control" content="no-cache">
// 其他主流浏览器识别的标签
<meta http-equiv="expires" content="0">
// 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段
```

2. html设置缓存如下：

```html
<meta http-equiv="Cache-Control" content="max-age=7200" />
// 其他主流浏览器识别的标签
<meta http-equiv="Expires" content="Mon, 20  Aug 2018 23:00:00 GMT" />
// 仅有IE浏览器才识别的标签
```



#### 3、缓存控制

**HTTP/1.1**定义的 [`Cache-Control`](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FCache-Control) 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。

**没有缓存**

```js
Cache-Control: no-store
```

缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。



**缓存但重新验证**

```undefined
Cache-Control: no-cache
```

此方式下，每次有请求发出时缓存会将此请求发到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期（返回304），则缓存才使用本地缓存副本



**私有和公共缓存**

```cpp
Cache-Control: private
Cache-Control: public
```

"public" 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。

而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。



**过期**

```swift
Cache-Control: max-age=31536000
```

过期机制中，最重要的指令是 "`max-age=`"，表示资源能够被缓存（保持新鲜）的最大时间。



**浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？**

> 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载 相应的资源并进行离线存储。如果已经访问过 app，并且资源已经离线存储了， 如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资 源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如 果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文 件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源



#### 4、http报头&&状态码

> HTTP请求报文由请求行、请求头部、空行和请求数据4个部分组成，下图是请求报文的一般格式。
>
> HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。



![http缓存-3](../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-3.jpg)



| 状态码 | 描述                     |
| ------ | ------------------------ |
| 1xx    | 提示信息，请求被成功接收 |
| 2xx    | 成功，请求被成功处理 200 |
| 3xx    | 重定向相关 304           |
| 4xx    | 客户端错误 404           |
| 5xx    | 服务端错误 500           |

> 200 成功处理了请求，一般情况下都是返回此状态码；
> 201 请求成功并且服务器创建了新的资源。
> 202 接受请求但没创建资源；
> 203 返回另一资源的请求；

>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。
>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。

>400 服务器不理解请求的语法。
>401 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
>403 服务器拒绝请求。
>404 服务器找不到请求的网页。
>408 服务器等候请求时发生超时。
>410 如果请求的资源已永久删除，服务器就会返回此响应。
>413 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
>414 请求的 URI（通常为网址）过长，服务器无法处理。

>500 （服务器内部错误） 服务器遇到错误，无法完成请求。
>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。



#### 5、HTTP与HTTPS有什么区别？

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。

简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS和HTTP的区别主要如下：

> 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
>
> 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
>
> 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
>
> 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### GET和POST的区别



> GET在浏览器回退时是无害的，而POST会再次提交请求。
> GET产生的URL地址可以被Bookmark，而POST不可以。
> GET请求会被浏览器主动cache，而POST不会，除非手动设置。
> GET请求只能进行url编码，而POST支持多种编码方式。
> GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
> GET请求在URL中传送的参数是有长度限制的，而POST么有。
> 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
> GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
> GET参数通过URL传递，POST放在Request body中。

首先从安全性讲，get和post都一样，没啥所谓的哪个更安全
get请求参数在url地址上，直接暴露，post请求的参数放body部分，按F12也直接暴露了，所以没啥安全性可言。

GET参数通过URL传递，POST放在Request body中”这个其实也不准，post请求也可以没body，也可以在url传递呢？

**GET和POST有一个重大区别**
GET产生一个TCP数据包；POST产生两个TCP数据包。也就是说：
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。



### WebStorage：

Web Storage的目的是为了克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是：

- 提供一种在cookie之外存储会话数据的途径。
- 提供一种存储大量可以跨会话存在的数据的机制。

Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。从字面意思就可以很清楚的看出来，sessionStorage将数据保存在session中，浏览器关闭也就没了；而localStorage则一直将数据保存在客户端本地。其API提供的方法有以下几种：

```csharp
    - setItem (key, value) ——  保存数据，以键值对的方式储存信息。

    - getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。

    - removeItem (key) ——  删除单个数据，根据键值移除对应的信息。

    - clear () ——  删除所有的数据

    - key (index) —— 获取某个索引的key
```

#### localStorage

localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。使用方法如下：

```dart
var storage = null;
if(window.localStorage){              //判断浏览器是否支持localStorage
     storage = window.localStorage;     
     storage.setItem("name", "Rick");    //调用setItem方法，存储数据
     alert(storage.getItem("name"));     //调用getItem方法，弹框显示 name 为 Rick
     storage.removeItem("name");     //调用removeItem方法，移除数据
     alert(storage.getItem("name"));   //调用getItem方法，弹框显示 name 为 null
}
```

localStorage 相对sessionStorage简单一点，需要注意的地方不是很多。

#### sessionStorage

sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。需要注意的有以下几点：

- 页面刷新不会消除数据;
- 只有在当前页面打开的链接，才可以访sessionStorage的数据；
- 使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据;



#### WebStorage与cookie的区别：

> cookie是在HTML4中使用的给客户端保存数据的，也可以和session配合实现跟踪浏览器用户身份；

 

**相同点：**

 cookie，localStorage，sessionStorage都是在客户端保存数据的，存储数据的类型：都是字符串。

**不同点：**

1. 生命周期：

> 1）、cookie如果不设置有效期，那么就是临时存储（存储在内存中），是会话级别的，会话结束后，cookie也就失效了，如果设置了有效期，那么cookie存储在硬盘里，有效期到了，就自动消失了。
>
> 2）、localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。
>
> 3）、sessionStorage仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。
>
> 可以简单的理解为：sessionStorage，没有设置有效期的cookie。
>
> 如果说把cookie的有效期设置为永远永远，永久，那么就是localStorage。
>
> cookie没有设置有效期，那么就是sessionStorage                  

2. 网络流量：cookie的数据每次都会发给服务器端，而localstorage和sessionStorage不会与服务器端通信，纯粹为了保存数据，所以，webstorage更加节约网络流量。

3. 大小限制：cookie大小限制在4KB，非常小；localstorage和sessionStorage在5M

4. 安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获。



#### cookie的配置：

通常我们有两种方式给浏览器设置或获取Cookie：

- 第一种 通过 HTTP 方式对 Cookie 进行赋值，又分为 Request 和 Response：

- - HTTP Response Headers 中的 Set-Cookie Header
  - HTTP Request Headers 中的 Cookie Header

- 第二种 通过JavaScript对document.cookie进行赋值或取值。

**1. HTTP Cookie**

Set-Cookie Header，除了必须包含Cookie正文，还可以选择性包含6个属性：

```text
path、domain、max-age、expires、secure、httponly
```

它们之间用英文分号和空格（"; "）连接，示例：

```http
Set-Cookie:
  key=value; 
  path=path;
    domain=domain;
    max-age=max-age-in-seconds;
    expires=date-in-GMTString-format;
    secure; httponly
```

**JS Cookie**

在浏览器端，通过 document.cookie 也可以设置Cookie，JS Cookie 的内容除了必须包含正文之外，还可选5个属性：

```text
path、domain、max-age、expires、secure
```

下面是简单的示例：

```js
document.cookie = "key=value; path=path; domain=domain; max-age=max-age-in-seconds; expires=date-in-GMTString-format; secure";
```

JS 中设置 Cookie 和 HTTP 方式相比较，少了对 **HttpOnly** 的控制，是因为 JS 不能读写HttpOnly Cookie。



## 浏览器安全相关

### 盗用cookie的手段

在别的浏览器中来冒用合法用户访问系统；黑客自然不能手动拿你浏览器中的cookie值，除非黑客就是你身边的人，那他就不是黑客了，是盗贼；

黑客都是靠技术手段获取别人的东西，例如：利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页中，然后自动从用户浏览器中获取cookie的值，此技术手段被称为[**XSS攻击**](https://blog.csdn.net/zemprogram/article/details/109451863)；

**如果cookie中设置了HttpOnly属性，且为true，那么通过js脚本将无法读取到cookie信息，这样就能有效的防止XSS攻击，防止cookie内容被盗窃。**

### SYN攻击

　　 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.
    Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。
    Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.



## 参考文献

[【THE LAST TIME】彻底吃透 JavaScript 执行机制](https://juejin.cn/post/6844903955286196237)

[【THE LAST TIME】一文吃透所有JS原型相关知识点](https://juejin.cn/post/6844903984335945736)

[你所不知道的HostOnly Cookie](https://imququ.com/post/host-only-cookie.html)

[计算机网络--网络攻击XSS与CSRF](https://blog.csdn.net/zemprogram/article/details/109451863)

[CSS Flex 弹性布局（一） - 阮一峰](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

[CSS Flex 弹性布局（二） - 阮一峰](https://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

[CSS Grid 网格布局 - 阮一峰](https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)

[TypeScript 中文手册](https://typescript.bootcss.com/)

[TypeScript-相关试题](https://www.jianshu.com/p/c8aaba6e8ce0)

[深度剖析JavaScript ES5/ AMD/ CMD/ COMMONJS/ ES6模块化](https://blog.csdn.net/qq_27575925/article/details/113758050)

