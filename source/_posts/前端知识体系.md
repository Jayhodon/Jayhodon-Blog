---
title: 前端知识体系

date: 2021-07-10 12:55:28

tags: [前端,个人知识库]

categories: [前端,个人知识库]

---



# 前端知识体系

> ​	这篇文章的目标主要是梳理出一个较为完整的个人前端向知识体系。文章主要是以**从输入URL到页面加载**这个问题所梳理的文章，由于这个问题所涵盖的面十分的广阔，可以说是非常适合个人前端知识体系的搭建了。



## 搭建基础架构

对于个人知识体系的搭建，最为重要的一点便是对基础架构的搭建，有了一个大体的架构后才方便填充细节。以下便是**从输入URL到页面加载**的一个基础架构：

>1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
>2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）
>3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
>
>4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
>
>5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）
>
>6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）
>
>7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）
>
>8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
>
>9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）



### 从浏览器接收url到开启网络请求线程



#### 多进程的浏览器

由于浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）

> 进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等
>
> - Browser进程：浏览器的主进程（负责协调、主控），只有一个
> - 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
> - GPU进程：最多一个，用于3D绘制
> - 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）



#### 多线程的浏览器内核

每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程

![内核线程](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/kernel-thread.jpg)

可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的

#### 解析URL

输入URL后，会进行解析（URL的本质就是统一资源定位符）

URL一般包括几大部分：

>`protocol`，协议头，譬如有http，ftp等
>
>`host`，主机域名或IP地址
>
>`port`，端口号
>
>`path`，目录路径
>
>`query`，即查询参数
>
>`fragment`，即`#`后的hash值，一般用来定位到某个位置

#### 网络请求都是单独的线程

每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载



### 开启网络线程到发出一个完整的http请求

#### DNS查询得到IP

如果输入的是域名，需要进行dns解析成IP，大致流程：

>- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
>- 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP

注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）

而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑`dns-prefetch`优化

#### tcp/ip请求

http的本质就是 tcp/ip 请求,且tcp/ip协议是传输层面向连接的一个安全可靠的连接协议。tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输，这里需要了解3次握手规则建立连接以及断开连接时的四次挥手。

#### TCP报文格式

![tcp报文格式](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-message-format.jpg)

> 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
>
> 
>
> 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
>
> ​	URG：紧急指针（urgent pointer）有效。
>
> ​	ACK：确认序号有效。
>
> ​	PSH：接收方应该尽快将这个报文交给应用层。
>
> ​	RST：重置连接。
>
> ​	SYN：发起一个新连接。
>
> ​	FIN：释放一个连接。

需要注意的是：

（A）不要将确认序号Ack与标志位中的ACK搞混了。

（B）确认方Ack=发起方Req+1，两端配对。

#### **三次握手的步骤：**

采用三次握手建立一个安全可靠的连接.

>客户端：hello，你是server么？
>服务端：hello，我是server，你是client么
>客户端：yes，我是client

具体过程如下:

建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。

![3次握手](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-handshake.jpg)

> 第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
>
> SYN：同步序列编号(Synchronize Sequence Numbers)
>
> 第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
>
> 第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.

**为什么需要三次握手，是为了解决下列的一个问题:**

> ​	   client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了， 以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。
>
> ​	假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生

建立连接成功后，接下来就正式传输数据

然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）

#### **四次挥手的步骤：**

四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
>被动方：收到通道关闭的信息，但是我的工作可能还没完成
>被动方：ok 我的工作完成了，我这边向你的主动通道也关闭了
>主动方：最后收到数据，之后双方无法通信

具体过程如下:

![4次挥手](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave.jpg)

​	由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

> 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
>
> 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
>
> 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
>
> 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

​	上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：![tcp4次挥手-同时](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave-meanwhile.jpg)

​	如果有大量的连接，每次在连接、关闭时都要三次握手，四次挥手，会很明显会造成性能低下，因此，HTTP有一种叫做keep connection的机制，它可以在传输数据后仍然保持连接，当客户端再次获取数据时，直接使用刚刚空闲下的连接而无需再次握手

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

> 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**如果已经建立了连接，但是客户端突然出现故障了怎么办？**

> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

**tcp/ip的并发限制**

浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）

而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求

所以针对这个瓶颈，又出现了很多的资源优化方案

### get和post的区别

get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。

get会产生一个tcp数据包，post两个

具体就是：

- get请求时，浏览器会把`headers`和`data`一起发送出去，服务器响应200（返回数据），
- post请求时，浏览器先发送`headers`，服务器响应`100 continue`，

浏览器再发送`data`，服务器响应200（返回数据）。

再说一点，这里的区别是`specification`（规范）层面，而不是`implementation`（对规范的实现）

### 五层因特网协议栈

其实就是一个概念：

**从客户端发出http请求到服务器接收，中间会经过一系列的流程。**

简括就是：

**从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。**

当然，服务端的接收就是反过来的步骤

五层因特网协议栈其实就是：

>1.应用层(dns,http) DNS解析成IP并发送http请求
>
>2.传输层(tcp,udp) 建立tcp连接（三次握手）
>
>3.网络层(IP,ARP) IP寻址
>
>4.数据链路层(PPP) 封装成帧
>
>5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。

OSI七层框架：`物理层`、`数据链路层`、`网络层`、`传输层`、`会话层`、`表示层`、`应用层`

>表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等
>
>会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程
