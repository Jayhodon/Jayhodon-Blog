---
title: 前端知识体系

date: 2021-07-10 12:55:28

tags: [前端,个人知识库]

categories: [前端,个人知识库]

summary: '这篇文章的目标主要是梳理出一个较为完整的个人前端向知识体系。文章主要是以**从输入URL到页面加载**这个问题所梳理的文章，由于这个问题所涵盖的面十分的广阔，可以说是非常适合个人前端知识体系的搭建了。'
---



# 前端知识体系

> ​	这篇文章的目标主要是梳理出一个较为完整的个人前端向知识体系。文章主要是以**从输入URL到页面加载**这个问题所梳理的文章，由于这个问题所涵盖的面十分的广阔，可以说是非常适合个人前端知识体系的搭建了。



## 搭建基础架构

对于个人知识体系的搭建，最为重要的一点便是对基础架构的搭建，有了一个大体的架构后才方便填充细节。以下便是**从输入URL到页面加载**的一个基础架构：

>1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
>2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）
>3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
>
>4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
>
>5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）
>
>6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）
>
>7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）
>
>8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
>
>9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）



### 从浏览器接收url到开启网络请求线程



#### 多进程的浏览器

由于浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）

> 进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等
>
> - Browser进程：浏览器的主进程（负责协调、主控），只有一个
> - 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
> - GPU进程：最多一个，用于3D绘制
> - 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）



#### 多线程的浏览器内核

每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程

![内核线程](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/kernel-thread.jpg)

可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的

#### 解析URL

输入URL后，会进行解析（URL的本质就是统一资源定位符）

URL一般包括几大部分：

>`protocol`，协议头，譬如有http，ftp等
>
>`host`，主机域名或IP地址
>
>`port`，端口号
>
>`path`，目录路径
>
>`query`，即查询参数
>
>`fragment`，即`#`后的hash值，一般用来定位到某个位置

#### 网络请求都是单独的线程

每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载



### 开启网络线程到发出一个完整的http请求

#### DNS查询得到IP

如果输入的是域名，需要进行dns解析成IP，大致流程：

>- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
>- 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP

注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）

而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑`dns-prefetch`优化

#### tcp/ip请求

http的本质就是 tcp/ip 请求,且tcp/ip协议是传输层面向连接的一个安全可靠的连接协议。tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输，这里需要了解3次握手规则建立连接以及断开连接时的四次挥手。

#### TCP报文格式

![tcp报文格式](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-message-format.jpg)

> 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
>
> 
>
> 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
>
> ​	URG：紧急指针（urgent pointer）有效。
>
> ​	ACK：确认序号有效。
>
> ​	PSH：接收方应该尽快将这个报文交给应用层。
>
> ​	RST：重置连接。
>
> ​	SYN：发起一个新连接。
>
> ​	FIN：释放一个连接。

需要注意的是：

（A）不要将确认序号Ack与标志位中的ACK搞混了。

（B）确认方Ack=发起方Req+1，两端配对。

#### **三次握手的步骤：**

采用三次握手建立一个安全可靠的连接.

>客户端：hello，你是server么？
>服务端：hello，我是server，你是client么
>客户端：yes，我是client

具体过程如下:

建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。

![3次握手](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-handshake.jpg)

> 第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
>
> SYN：同步序列编号(Synchronize Sequence Numbers)
>
> 第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
>
> 第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.

**为什么需要三次握手，是为了解决下列的一个问题:**

> ​	   client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了， 以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。
>
> ​	假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生

建立连接成功后，接下来就正式传输数据

然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）

#### **四次挥手的步骤：**

四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
>被动方：收到通道关闭的信息，但是我的工作可能还没完成
>被动方：ok 我的工作完成了，我这边向你的主动通道也关闭了
>主动方：最后收到数据，之后双方无法通信

具体过程如下:

![4次挥手](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave.jpg)

​	由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

> 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
>
> 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
>
> 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
>
> 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

​	上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：![tcp4次挥手-同时](../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave-meanwhile.jpg)

​	如果有大量的连接，每次在连接、关闭时都要三次握手，四次挥手，会很明显会造成性能低下，因此，HTTP有一种叫做keep connection的机制，它可以在传输数据后仍然保持连接，当客户端再次获取数据时，直接使用刚刚空闲下的连接而无需再次握手

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

> 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**如果已经建立了连接，但是客户端突然出现故障了怎么办？**

> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

**tcp/ip的并发限制**

浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）

而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求

所以针对这个瓶颈，又出现了很多的资源优化方案

### get和post的区别

get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。

get会产生一个tcp数据包，post两个

具体就是：

- get请求时，浏览器会把`headers`和`data`一起发送出去，服务器响应200（返回数据），
- post请求时，浏览器先发送`headers`，服务器响应`100 continue`，

浏览器再发送`data`，服务器响应200（返回数据）。

再说一点，这里的区别是`specification`（规范）层面，而不是`implementation`（对规范的实现）

### 五层因特网协议栈

其实就是一个概念：

**从客户端发出http请求到服务器接收，中间会经过一系列的流程。**

简括就是：

**从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。**

当然，服务端的接收就是反过来的步骤

五层因特网协议栈其实就是：

>1.应用层(dns,http) DNS解析成IP并发送http请求
>
>2.传输层(tcp,udp) 建立tcp连接（三次握手）
>
>3.网络层(IP,ARP) IP寻址
>
>4.数据链路层(PPP) 封装成帧
>
>5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。

OSI七层框架：`物理层`、`数据链路层`、`网络层`、`传输层`、`会话层`、`表示层`、`应用层`

>表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等
>
>会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程



## 性能优化



### 性能优化相关

#### 前端性能优化常用的方法有哪些?

前端性能优化是提升网页加载速度和用户体验的重要手段。以下是一些常用的前端性能优化方法：

1. **减少HTTP请求**：HTTP请求是网页加载速度的主要瓶颈之一。减少HTTP请求的方法包括：
   - 合并CSS和JavaScript文件，减少文件数量。
   - 使用CSS Sprites技术，将多个小图标合并成一张大图，减少图片请求。
   - 利用浏览器缓存，对于不经常变动的资源，设置合适的缓存策略。
2. **优化图片**：图片是网页中占用带宽较多的资源之一。优化图片的方法包括：
   - 压缩图片大小，使用合适的图片格式（如JPEG、PNG、SVG等）。
   - 使用图片懒加载（Lazy Loading）技术，延迟加载用户当前视口外的图片。
   - 使用WebP格式的图片，它具有更好的压缩性能和显示效果。
3. **使用CDN**：CDN（内容分发网络）可以将资源缓存到离用户更近的节点上，提高资源加载速度。
4. **优化JavaScript**：JavaScript的执行会影响网页的渲染速度。优化JavaScript的方法包括：
   - 将JavaScript脚本放在页面底部，避免阻塞页面的渲染。
   - 使用异步加载JavaScript，如使用`<script async>`标签。
   - 避免使用全局变量和不必要的计算，减少内存占用和CPU消耗。
   - 利用浏览器的缓存机制，将JavaScript文件缓存到本地。
5. **优化CSS**：CSS的加载和解析也会影响网页的渲染速度。优化CSS的方法包括：
   - 将CSS代码放在HTML页面的头部，确保页面在加载过程中尽早应用样式。
   - 避免使用CSS表达式和复杂的CSS选择器，减少浏览器的计算量。
   - 利用CSS的继承性和层叠性，减少重复的代码。
   - 使用CSS预处理器（如Sass、Less等）编写更简洁、可维护的CSS代码。
6. **DOM优化**：DOM（文档对象模型）是网页的基础结构。优化DOM的方法包括：
   - 减少DOM元素的数量，避免不必要的嵌套和冗余元素。
   - 使用DocumentFragment或innerHTML批量操作DOM，减少DOM操作次数。
   - 避免频繁地读取DOM样式和属性，可以使用变量缓存DOM样式。
   - 使用虚拟DOM技术，提高DOM操作的性能。
7. **使用Web Workers**：Web Workers是运行在后台的JavaScript线程，不会阻塞页面的渲染。可以使用Web Workers处理一些耗时的计算任务，提高页面的响应速度。
8. **压缩和编码**：使用Gzip等压缩技术对网页资源进行压缩，减少传输的数据量。同时，使用正确的字符编码（如UTF-8）可以提高网页的解析速度。
9. **利用缓存**：利用浏览器缓存、CDN缓存等机制，减少重复请求和资源加载时间。
10. **减少重绘和重排**：重绘和重排是浏览器渲染页面的两个重要过程，但它们的性能开销较大。可以通过减少元素的样式变化和布局变化来减少重绘和重排的次数。

以上是一些常用的前端性能优化方法，可以根据具体的项目需求和场景选择合适的优化手段。



#### 浏览器中LightHouse v8/v9性能优化指标有哪些？

在浏览器的Lighthouse中，无论是v8还是v9版本，性能优化指标主要包括以下几个方面：

1. 首次内容渲染（First Contentful Paint, FCP）
   - 这是页面首次渲染出文本或图片的时间。FCP衡量的是用户看到页面上的第一个元素（例如文本、图片等）的时间。
2. 最大内容绘制（Largest Contentful Paint, LCP）
   - LCP标识网页渲染出最大文本或图片的时间。这是用户看到页面上主要内容的时间点。
3. 可交互时间（Time to Interactive, TTI）
   - 这是页面达到可交互状态所需的时间。在这个时间点之后，用户可以开始与页面进行交互，如点击按钮或链接。
4. 累计布局偏移（Cumulative Layout Shift, CLS）
   - CLS衡量页面上内容意外偏移的程度。当页面元素在用户交互或加载过程中发生移动时，会导致CLS分数增加，这会给用户带来不良的体验。
5. 累计阻塞时间（Total Blocking Time, TBT）
   - TBT标识网页首次内容渲染和可交互时间之间的所有超时任务的超时累计时间。这主要反映了页面在加载过程中主线程被阻塞的总时间。

除了上述主要性能指标外，Lighthouse还可能会提供其他与性能相关的指标，例如：

- **速度指数（Speed Index）**：衡量页面内容的可见填充速度。
- **首次有效绘制（First Meaningful Paint, FMP）**：虽然FMP不是Lighthouse的核心指标，但在某些版本中可能会提供，它衡量的是主要内容对用户可见的时间。

请注意，随着Lighthouse版本的更新，可能会有新的性能指标被引入或旧的指标被优化。因此，最好直接查看Lighthouse的官方文档或工具本身以获取最准确和最新的信息。



#### SPA首屏加载速度慢的怎么解决？

SPA（单页应用）首屏加载速度慢的问题，通常可以通过以下几种方法来解决：

1. 减小入口文件体积
   - 通过代码分割（Code Splitting）和懒加载（Lazy Loading）技术，将代码拆分成多个小块，按需加载，从而减小首屏加载时需要的文件大小。
   - 路由懒加载：将不同路由对应的组件分割成不同的代码块，只有在需要加载对应路由时，才加载对应的组件代码。
   - 抽离公共组件避免重复打包：将公共的库或组件单独打包，避免在多个页面中重复加载。
2. 优化图片资源
   - 图片压缩：使用工具对图片进行压缩，减小图片的体积。
   - 图片懒加载：对于非首屏的图片，使用懒加载技术，当用户滚动到图片位置时才加载图片。
3. 静态资源本地缓存
   - 利用浏览器的缓存机制，对静态资源进行缓存，避免重复加载。
   - 使用CDN（内容分发网络）加速静态资源的加载。
4. 优化网络请求
   - 减少HTTP请求的数量，合并多个请求到一个请求中。
   - 使用HTTP/2协议，它支持多路复用，可以并行发送多个请求，提高加载速度。
5. 按需加载第三方库和插件
   - 不要一次性加载所有的第三方库和插件，而是根据需要使用它们时才加载。
   - 使用CDN引用第三方库和插件，减轻服务器的负载。
6. 使用SSR（服务器端渲染）
   - 对于首屏渲染需要的数据，可以在服务器端进行渲染，然后将渲染好的页面发送到客户端，这样可以减少客户端的渲染时间。
7. 开启GZip压缩
   - 对传输的数据进行GZip压缩，减小传输的数据量，提高加载速度。
8. 优化DOM操作
   - 减少不必要的DOM操作，避免频繁的DOM读写和重排重绘。
   - 使用虚拟DOM技术，提高DOM操作的性能。
9. 优化CSS和JavaScript
   - 合并和压缩CSS和JavaScript文件，减少文件数量和大小。
   - 使用CSS Sprites技术合并小图片，减少图片请求的数量。
   - 避免在JavaScript中执行复杂的计算和循环操作，优化算法和数据结构。
10. 优化服务器性能
    - 确保服务器具有足够的处理能力，可以快速响应客户端的请求。
    - 使用负载均衡技术，将请求分发到多个服务器上进行处理，提高整体的处理能力。

通过综合应用以上方法，可以有效地解决SPA首屏加载速度慢的问题，提升用户体验。





#### 如何优化LCP？

优化LCP（Largest Contentful Paint）是提升网页性能的重要方面，它表示从用户开始加载网页到最大的图片或文本块在视口中呈现之间的时间。以下是一些优化LCP的策略：

1. 减少服务器响应时间
   - 优化服务器性能，确保服务器可以快速响应请求。
   - 使用CDN（内容分发网络）来缓存资源，并将资源分发到离用户更近的地理位置，从而减少加载时间。
   - 提前建立第三方连接，以减少等待时间。
2. 优化资源加载
   - 压缩和优化图片、脚本和样式表等资源的大小，以减少传输时间。
   - 使用HTTP/2或HTTP/3协议，它们支持流复用，可以同时加载多个资源，提高加载效率。
   - 对资源进行异步加载和延迟加载，避免阻塞渲染过程。
3. 代码分割和懒加载
   - 使用代码分割技术将代码拆分成多个小块，按需加载，从而减小首次加载时需要的文件大小。
   - 对于非首屏的内容或组件，使用懒加载技术，当用户需要时才加载。
4. 优化渲染过程
   - 避免在渲染过程中执行复杂的计算和循环操作，优化算法和数据结构。
   - 使用Web Workers在后台线程中执行耗时的计算任务，避免阻塞主线程。
   - 提取关键CSS并将其内联到HTML的`<head>`部分中，以确保在渲染首屏内容时关键样式已经可用。
5. 优化DOM操作
   - 减少不必要的DOM操作，避免频繁的DOM读写和重排重绘。
   - 使用虚拟DOM技术来减少真实DOM操作，提高性能。
6. 使用缓存
   - 利用浏览器缓存机制，缓存已经加载过的资源，避免重复加载。
   - 对于静态资源，使用长缓存策略，减少请求次数。
7. 监控和测试
   - 使用Lighthouse等性能测试工具来监控和测试LCP等性能指标，找出性能瓶颈并进行优化。
   - 在不同设备和网络环境下进行测试，确保网页在各种条件下都能有良好的性能表现。

请注意，优化LCP是一个综合性的过程，需要综合考虑多个方面。通过持续的性能监控和测试，你可以发现潜在的性能问题并进行优化，从而提升网页的加载速度和用户体验。



#### 前端性能优化指标RAIL是什么？

RAIL是Google提出的一个以用户为中心的前端性能模型，它包含了四个关键性能指标，旨在帮助开发者提高网页的性能和用户体验。RAIL分别代表以下四个方面：

1. **Response（响应）**：指的是Web应用给用户的响应体验，包括用户输入到系统响应的时间。RAIL建议用户输入到响应时间不要超过100ms，给用户的感觉是瞬间完成的。如果响应时间在50ms到100ms之间，最好提供反馈，如加载进度或倒计时，以改善用户的心理预期。
2. **Animation（动画）**：动画是提高用户体验的重要元素，但添加的动画必须流畅。RAIL建议每帧动画在10ms内产生，因为一般浏览器的刷新率是60帧每秒，即每16.6ms刷新一次。为了保证视觉上的平滑，每帧动画最好不要超过10ms。
3. **Idle（空闲）**：指的是让浏览器（主线程）有足够的空闲时间处理用户的交互，而不是一直在繁忙状态。RAIL建议最大化空闲时间，以增大50ms内响应用户输入的几率。开发者可以利用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分。
4. **Load（加载）**：指的是网络加载时间。RAIL建议在5秒内完成内容的加载并且可以交互。加载时间过长会导致用户失去耐心，甚至离开网页。

通过关注这四个方面的性能指标，开发者可以更加全面地评估和优化前端性能，提高用户体验。同时，RAIL也提供了一些具体的优化策略和建议，帮助开发者更好地实施性能优化。



#### ssr的优缺点，实现的具体过程

SSR，即服务端渲染（Server-Side Rendering），是一种Web开发中的渲染技术，与传统的客户端渲染（Client-Side Rendering）相对应。下面我将详细解释SSR的优缺点以及实现的具体过程。

一、SSR的优点：

1. 更好的性能：SSR可以在服务器端预先渲染页面，减少客户端的渲染时间，提高页面加载速度。由于服务器通常具有更强大的计算能力，因此可以更快地生成HTML页面。
2. 更好的SEO：由于页面在服务器端已经被渲染成HTML，搜索引擎爬虫可以直接抓取到页面的内容，有利于SEO优化。与客户端渲染相比，SSR更容易被搜索引擎识别和索引。
3. 更适合复杂页面：对于包含大量数据、需要复杂计算的页面，SSR可以更好地处理并减少客户端的负载。服务器可以处理更复杂的逻辑和数据，然后将渲染好的页面发送给客户端。

二、SSR的缺点：

1. 开发限制：SSR要求开发者在编写Vue组件时，需要考虑到服务器端和客户端环境的差异，不能过度依赖客户端环境。这可能会增加开发的复杂性和难度。
2. 服务器压力：由于页面在服务器端进行渲染，会增加服务器的负载压力。特别是在高并发场景下，服务器可能会成为性能瓶颈。
3. 调试困难：SSR的调试过程相对复杂，需要同时考虑到服务器端和客户端的日志和错误信息。这可能会增加开发和维护的难度。

三、SSR实现的具体过程：

1. 接收请求：当客户端向服务器发送请求时，服务器会接收这个请求。
2. 渲染页面：服务器在接收到请求后，会根据请求的URL或其他参数，使用Vue或其他前端框架来渲染页面。这个过程包括加载组件、执行数据请求、渲染HTML等步骤。
3. 发送响应：当页面渲染完成后，服务器会将生成的HTML页面作为响应发送给客户端。这个HTML页面已经包含了页面的结构和数据，客户端只需要展示这个页面即可。
4. 客户端激活：客户端在接收到HTML页面后，会解析并展示这个页面。同时，客户端还会加载并执行页面中的JavaScript代码，以便实现交互和动态功能。

需要注意的是，SSR并不是所有情况下都是最优的选择。在一些简单的页面或需要快速响应的场景下，客户端渲染可能更加适合。因此，在选择使用SSR时，需要根据具体的业务需求和技术栈来综合考虑。



#### 怎么分析性能？

性能分析是一个复杂但重要的过程，用于确保软件或系统满足其设计的性能期望。以下是一些常用的性能分析方法：

1. 性能分析工具
   - 使用专门的性能分析工具，如GDB、Xcode Instruments（针对macOS）、Intel VTune Profiler（多平台支持）和Perf（Linux）等，可以收集关于函数调用、变量值、CPU使用率、内存分配和I/O操作等关键信息。
   - 这些工具通常具有不同的特点和优势，选择适合您项目需求的工具是关键。
2. 性能分析原则
   - 首先，从原始测试数据查看系统响应时间，判断它是否满足用户性能的期望。
   - 如果存在问题，判断系统的瓶颈是出现在网络环节还是服务器环节。
3. 性能分析步骤
   - 从分析summary的事务执行情况入手，了解整体性能情况。
   - 查看负载发生器和服务器的系统资源情况，包括负载是否均衡、CPU利用率、内存使用情况以及是否有内存泄露等。
   - 深入查看虚拟用户与事务的详细执行情况，如虚拟用户运行情况、事务响应时间是否增长等。
   - 检查错误发生情况，找出导致性能问题的根本原因。
   - 对于web性能测试，还需要分析web资源和细分网页，重点分析服务器的稳定性，找出哪些环节比较耗时，以及页面中哪些组成部分对用户响应时间影响最大。
4. 诊断方法
   - **随机变动法**：随机调整指标，看是否改善。
   - **Ad Hoc核对清单法**：针对清单，一项项核对。
   - **问题陈述法**：详细询问客户，明确问题性质、范围。
   - **USE法**：综合考虑资源和效率，根据资源（CPU、内存、网络、磁盘等）的使用率（Usage）、饱和度（Saturation）、报错（Error）来排查问题。
   - **延时分析法**：将业务分解，通过分析每一步骤的延时，定位问题所在。
5. 代码优化
   - 通过对代码进行审查和优化，可以减少不必要的计算和内存使用，提高程序的执行效率。
   - 例如，使用代码分割和懒加载技术，可以减少首次加载时需要的文件大小，提高页面加载速度。
6. 监控和日志分析
   - 实时监控系统的运行状态和性能指标，及时发现并解决问题。
   - 通过分析日志文件，可以了解系统的运行情况、错误信息和性能瓶颈等关键信息。

请注意，性能分析是一个持续的过程，需要不断地收集和分析数据，以便及时发现问题并进行优化。同时，不同的项目和需求可能需要使用不同的性能分析方法和工具，因此需要根据具体情况进行选择。
