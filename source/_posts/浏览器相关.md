---
title: 浏览器相关
date: 2023-05-23 15:46:33
tags: [前端]
categories: [前端,个人知识库]
summary: '一篇了解、剖析浏览器相关原理知识点的手作指北。'
---



### 浏览器渲染流程

#### Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程

> **线程和进程区别**：多线程可以并行处理任务，线程不能单独存在，它是由进程来启动和管理的。一个进程是一个程序的运行实例。
>
> **线程和进程的关系**：1、进程中任意一线程执行出错，都会导致整个进程的崩溃。2、线程之间共享进程中的数据。3、当一个进程关闭后，操作系统会回收进程所占用的内存。4、进程之间的内容相互隔离。
>
> **单进程 浏览器**：1、不稳定。单进程中的插件、渲染线程崩溃导致整个浏览器崩溃。2、不流畅。脚本（死循环）或插件会使浏览器卡顿。3、不安全。插件和脚本可以获取到操作系统任意资源。
>
> **多进程浏览器**：1、解决不稳定。进程相互隔离，一个页面或者插件崩溃时，影响仅仅时当前插件或者页面，不会影响到其他页面。2、解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。3、解决不安全。采用多进程架构使用沙箱。沙箱看成时操作系统给进程上来一把锁，沙箱的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。
>
> **多进程架构**：分为 浏览器进程、渲染进程、GPU 进程、网络进程、插件进程。
>
> **缺点**：1、资源占用高。2、体系架构复杂。
>
> **面向服务架构**：把原来的各种模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 通讯，使得系统更内聚、松耦合、易维护和拓展。



#### TCP 协议：如何保证页面文件能被完整送达浏览器

> - IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息；
> - UDP 头中除了目的端口，还有源端口号等信息；
> - IP 负责把数据包送达目的主机；
> - UDP 负责把数据包送达具体应用；
> - 对于错误的数据包，UDP 不提供重发机制，只是丢弃当前的包，不能保证数据的可靠性，但是传输速度非常块；
> - TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接；



#### HTTP 请求流程：为什么很多站点第二次打开速度会很快

> - 浏览器中的 HTTP 请求从发起到结束一共经历如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接；
> - 构建请求。浏览器构建请求行，构建好后，准备发起网络请求；
> - 查找缓存。在真正发起请求前浏览器会查询缓存中是否有请求资源副本，有则拦截请求，返回资源副本，否则进入网络请求；
> - 准备 IP 地址和端口。HTTP 网络请求需要和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，浏览器需要请求 DNS 返回域名对应的 IP，同时会缓存域名解析结果，供下次查询使用；
> - 等待 TCP 队列。Chrome 机制，同一个域名同时最多只能建立 6 个 TCP 连接；
> - 建立 TCP 连接。TCP 通过“三次握手”建立连接，传输数据，“四次挥手”断开连接；
> - 发送 HTTP 请求。建立 TCP 连接后，浏览器就可以和服务器进行 HTTP 数据传输了，首先会向服务器发送请求行，然后以请求头形式发送一些其他信息，如果是 POST 请求还会发送请求体；
> - 服务器处理请求。首先服务器会返回响应行，随后，服务器向浏览器发送响应头和响应体。通常服务器返回数据，就要关闭 TCP 连接，如果请求头或者响应头有 Connection:keep-alive TCP 保持打开状态；



#### 导航流程：从输入 URL 到页面展示这中间发生了什么

> - 用户输入 URL 并回车
>
> - 浏览器进程检查 URL，组装协议，构成完整 URL
>
> - 浏览器进程通过进程通信（IPC）把 URL 请求发送给网络进程
>
> - 网络进程接收到 URL 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
>
> - 如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下：
>
> - - 进行 DNS 解析，获取服务器 IP 地址，端口
>   - 利用 IP 地址和服务器建立 tcp 连接
>   - 构建请求头信息
>   - 发送请求头信息
>   - 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
>
> - 网络进程解析响应流程：
>
> - - 检查状态码，如果是 301/302，则需要重定向，从 Location 自动读取地址，重新进行第 4 步，如果是 200，则继续处理请求
>   - 200 响应处理：检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续渲染。如果是 html 则通知浏览器进程准备渲染进程进行渲染
>
> - 准备渲染进程
>
> - - 浏览器进程检查当前 URL 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
>
> - 传输数据、更新状态
>
> - - 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
>   - 渲染进程接收完数据后，向浏览器发送“确认提交”
>   - 浏览器进程接收到确认消息后 engine 浏览器界面状态：安全、地址 URL、前进后退的历史状态、更新 web 页面

### 浏览器渲染相关

#### 渲染流程：HTML、CSS 和 JavaScript 是如何变成页面的

> - 浏览器不能直接理解 HTML 数据，需要将其转化为 DOM 树结构；
> - 生成 DOM 树后，根据 CSS 样式表，计算出 DOM 树所有节点样式；
> - 创建布局树：遍历 DOM 树所有可见节点，把这些节点加到布局中，不可见节点忽略，如 head 标签下所有内容，display: none 元素；
>
> - 分层：层叠上下文属性的元素（比如定位属性元素、透明属性元素、CSS 滤镜属性元素）提升为单独的一层，需要裁剪的地方（比如出现滚动条）也会被创建为图层；
> - 图层绘制：完成图层树构建后，渲染引擎会对图层树每一层进行绘制，把一个图层拆分成小的绘制指令，再把指令按照顺序组成一个带绘制列表；
> - 有些情况图层很大，一次绘制所有图层内容，开销太大，合成线程会将图层划分为图块（256x256 或者 512x512）；
> - 合成线程将图块提交给栅格线程进行栅格化，将图块转换为位图。栅格化过程都会使用 GPU 加速，生成的位图保存周期 GPU 内存中；
> - 一旦所有图块都被栅格化，合成线程会生成一个绘制图块命令（DrawQuad），然会将命令提交给浏览器进程，viz 组件接收到该指令，将页面内容绘制到内存中，显示在屏幕上；
> - 重排：通过 JavaScript 或者 CSS 修改元素几何位置属性，会触发重新布局，解析后面一系列子阶段；重绘：不引起布局变换，直接进入绘制及其以后子阶段；合成：跳过布局和绘制阶段，执行的后续操作，发生在合成线程，非主线程；



#### 渲染流水线：CSS 如何影响首次加载时的白屏时间？

> - DOM 构建结束之后，css 文件还未下载完成，渲染流水线空闲，因为下一步是合成布局树，合成布局树需要 CSSOM 和 DOM，这里需要等待 CSS 加载结束并解析成 CSSOM；
> - CSSOM 两个作用：提供给 JavaScript 操作样式表能力，为布局树的合成提供基础样式信息；
> - 在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转化为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。



#### 为什么操作 DOM 慢？

操作DOM（文档对象模型）慢的原因主要有以下几点：

> 1. **DOM操作引起浏览器的重绘（Repaint）和重排（Reflow）**：每次DOM操作（如添加、修改、删除节点或改变样式）都可能导致浏览器需要重新计算元素的几何属性（重排），并重新绘制页面上的部分内容或全部内容（重绘）。这两个过程都是相当耗时的，特别是当页面包含大量元素或复杂布局时。
> 2. **DOM操作与ECMAScript实现的分离**：在浏览器中，DOM的实现和ECMAScript（JavaScript的核心语言规范）的实现是分离的。这意味着当通过JavaScript代码操作DOM时，实际上是在两个相互独立的模块之间进行交互。这种跨模块的调用相比于在同一个模块内部进行调用，其性能损耗会更高。
> 3. **频繁的DOM查询和样式操作**：如果在代码中频繁地进行DOM查询或样式操作，会进一步增加浏览器的渲染负担。因为每次查询或操作都可能导致浏览器重新计算元素的属性或重新绘制页面。
> 4. **不必要的渲染**：如果对DOM进行不必要的操作（如频繁地改变元素的样式或位置），即使这些变化对最终的用户界面没有实际影响，也会导致浏览器进行额外的渲染工作，从而降低性能。

为了提高DOM操作的性能，可以采取以下策略：

> 1. **最小化DOM访问**：在JavaScript代码中尽可能减少对DOM的访问和操作。可以通过在循环外缓存DOM引用、使用局部变量等方式来减少DOM查询的次数。
> 2. **批量修改DOM**：如果需要对多个DOM元素进行修改，可以尝试将它们从文档流中移除（如使用`display: none`或`detach()`方法），对其进行批量修改后再重新插入到文档中。这样可以减少页面的重绘和重排次数。
> 3. **使用事件委托**：在父节点上监听事件，而不是在每个子节点上单独监听。这样可以减少事件处理程序的数量，提高性能。
> 4. **使用CSS类来修改样式**：尽量避免直接通过JavaScript修改DOM元素的样式属性。相反，可以使用CSS类来定义样式，并通过JavaScript来切换元素的类名。这样可以减少浏览器的重绘和重排次数。
> 5. **使用文档碎片（DocumentFragment）**：将多个DOM节点插入到文档碎片中，然后再将文档碎片一次性插入到文档中。这样可以减少页面的重绘次数。



#### 什么情况阻塞渲染？ 解析cssom 与 解析js 会阻碍渲染流程吗？

在浏览器的渲染过程中，有几种情况可能会导致渲染被阻塞：

> 1. **CSSOM的解析**：
>    - 当浏览器在构建渲染树时，它需要完整的DOM树和CSSOM树。如果CSSOM树还没有构建完成，那么渲染树的构建会被阻塞，从而导致页面渲染被延迟。这是因为页面渲染需要DOM树和CSS树合并成渲染树，然后才能开始渲染过程。
>    - 另外，如果JavaScript代码在执行过程中访问了某个元素的样式（即CSSOM），那么浏览器需要等待该样式被下载和解析完成才能继续执行JavaScript代码。这也可以看作是CSS阻塞了JavaScript的执行，从而间接地阻塞了渲染流程。
> 2. **JavaScript的解析和执行**：
>    - 当HTML解析器遇到`<script>`标签时，它会暂停DOM的解析，将控制权移交给JavaScript引擎来执行JavaScript代码。这意味着在JavaScript代码执行期间，DOM的解析和页面的渲染都会被阻塞。
>    - 如果`<script>`标签没有使用`async`或`defer`属性，那么浏览器会按照HTML文档中的顺序来加载和执行JavaScript代码。这可能会导致渲染被长时间阻塞，尤其是在JavaScript文件较大或网络较慢的情况下。

为了避免CSS和JavaScript阻塞渲染流程，可以采取以下策略：

> 1. **将CSS放在`<head>`中**：将CSS样式表放在HTML文档的`<head>`部分中，可以确保在DOM解析过程中尽早开始CSS的加载和解析。
> 2. **使用JavaScript的`async`和`defer`属性**：`async`属性允许浏览器异步加载和执行JavaScript代码，而不会阻塞DOM的解析。但是，使用`async`的JavaScript代码可能会按照不同的顺序执行，因此需要确保代码之间没有依赖关系。`defer`属性则会让浏览器在解析完整个HTML文档后再加载和执行JavaScript代码，这样可以确保在JavaScript代码执行时DOM已经完全解析完成。
> 3. **代码拆分和懒加载**：将JavaScript代码拆分成多个小文件，并使用懒加载技术来按需加载代码。这可以减少首次加载时需要加载的代码量，提高页面加载速度。
> 4. **使用Web Workers**：对于计算密集型任务，可以使用Web Workers在后台线程中执行JavaScript代码，而不会阻塞页面的渲染。但是需要注意的是，Web Workers不能直接访问DOM和CSSOM，因此它们主要用于执行与页面渲染无关的任务。



### 浏览器进程和线程相关

#### 介绍一下浏览器中的进程和线程

浏览器中的进程和线程是操作系统中用于管理和执行代码的基本单位，它们在浏览器中扮演着不同的角色，共同协作以实现浏览器的各种功能。

首先，我们来看进程。进程是操作系统分配资源的基本单位，每个进程都有自己的独立内存空间和系统资源。在浏览器中，主要有以下几种进程：

> 1. 浏览器进程：这是浏览器的主进程，负责协调和管理其他子进程。它的主要功能包括浏览器的界面显示、与用户交互（如前进、后退等）、管理各个页面、创建和销毁其他进程、网络资源的管理和下载等。
> 2. 渲染进程（Renderer进程）：通常被称为浏览器内核，是页面渲染的核心进程。每个渲染进程内部都是多线程的，主要负责页面的渲染、脚本的执行、事件的处理等。默认情况下，每打开一个新的标签页会开启一个新的渲染进程，以确保不同标签页之间代码的互不影响。
> 3. GPU进程：最多一个，用于3D绘制等图形处理任务。
> 4. 网络进程：负责网络资源的加载和管理，包括处理用户的网络请求、下载资源等。网络进程内部会启动多个线程来处理不同的网络任务。
> 5. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。

接下来是线程。线程是操作系统中能够被CPU调度和执行的最小单位。一个进程可以包含多个线程，它们共享进程的内存空间和资源，但每个线程都有自己的堆栈和局部变量等信息。线程可以看作是进程中的独立执行流，具有自己的执行路径、状态和优先级等属性。在浏览器中，主要有以下几种线程：

> 1. UI主线程：负责协调浏览器的整体运转，包括界面的渲染、用户交互的处理等。
> 2. JS引擎线程：负责执行JavaScript代码，包括解释执行js代码、处理用户输入、网络请求等。
> 3. GUI线程：负责渲染页面，绘制用户界面。由于JS可以操作DOM元素，进而影响到GUI的渲染效果，因此JS引擎线程与GUI渲染线程是互斥的，即当JS引擎线程处于运行状态时，GUI渲染线程将处于冻结状态。
> 4. HTTP网络请求线程：负责网络通信，处理用户的网络请求，并在返回结果后将回调函数推入任务队列。
> 5. 定时触发器线程：负责计时，当setTimeout、setInterval等待时间结束后，将执行函数推入任务队列中。
> 6. 浏览器事件处理线程：负责监听各种事件，如click、mouse等交互事件，并将这些事件放入事件队列中。

总的来说，浏览器中的进程和线程共同协作，以实现浏览器的各种功能和性能优化。每个进程和线程都有自己的特定角色和任务，通过它们之间的交互和协作，浏览器能够高效地加载、渲染和交互网页内容。



#### 什么情况下会导致浏览器的内存泄露 ？如何避免?

浏览器的内存泄露通常发生在以下几种情况：

> 1. **全局变量**：JavaScript对未声明的变量处理方式是在全局对象（在浏览器环境中为window对象）上创建该变量的引用。这些全局变量在窗口关闭或重新刷新页面之前都不会被释放，如果它们缓存了大量的数据，就会导致内存泄露。为了避免这种情况，应减少不必要的全局变量，并使用严格模式（'use strict'）来避免意外创建全局变量。
> 2. **闭包**：闭包可以读取函数内部的变量，并让这些变量始终保存在内存中。如果在使用闭包后没有正确清除其中的局部变量，就可能导致内存泄露。因此，需要在使用完闭包后及时解除其中的变量引用。
> 3. **事件监听**：对同一个事件重复监听但没有移除监听器，也会导致内存泄露。为了避免这种情况，应确保在不需要事件监听器时及时移除它们。
> 4. **控制台日志**：使用console.log打印的对象在控制台中不会被垃圾回收，这可能会导致内存泄露。因此，在生产环境中应避免使用console.log，或者在使用后及时清除控制台日志。

为了避免浏览器的内存泄露，可以采取以下措施：

> 1. **减少全局变量的使用**：尽量使用局部变量，并在使用完后及时清除它们的引用。
> 2. **合理使用闭包**：在闭包使用完毕后，及时清除其中的变量引用，确保内存得到释放。
> 3. **管理事件监听器**：在不需要事件监听器时及时移除它们，避免重复监听和内存泄露。
> 4. **避免在控制台中保留大量数据**：在生产环境中避免使用console.log，或者在使用后及时清除控制台日志。
> 5. **使用浏览器开发者工具**：利用浏览器的开发者工具来监控内存使用情况，及时发现并解决内存泄露问题。
> 6. **优化代码逻辑**：组织好代码逻辑，避免死循环等导致浏览器卡顿或崩溃的问题。

通过采取以上措施，可以有效地避免浏览器的内存泄露问题，提高浏览器的性能和稳定性。



#### Js是单线程还是多线程，浏览器如何支持多个Js线程？

**JavaScript是单线程语言**。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM（文档对象模型）。这种用途决定了它只能是单线程，否则会带来很复杂的同步问题。

然而，尽管JavaScript本身是单线程的，但现代浏览器通过一些技术使得JavaScript可以并发执行，从而支持多个线程。这主要通过**Web Workers**实现。Web Workers是一种浏览器端的后台线程，用于执行JavaScript代码。这些线程在后台运行，独立于其他脚本，不会影响页面的性能。Web Workers可以处理大量计算任务，而不会阻塞主线程，从而提高了Web应用的响应性和性能。

Web Workers可以分为两种类型：专用线程（Dedicated Worker）和共享线程（Shared Worker）。专用线程与创建它的脚本连接在一起，它可以与其他的worker或是浏览器组件通信，但不能与DOM通信。而共享线程可以在多个浏览器窗口或者标签页之间共享。

需要注意的是，虽然Web Workers可以创建多个线程，但这些线程之间的通信是通过消息传递实现的，而不是直接共享内存。因此，在传递大量数据时可能会出现性能问题。此外，Web Workers API只能在浏览器环境中使用，Node.js不支持Web Workers API。



#### 介绍下 Worker 线程

Worker线程，特别是在Web编程中，是一种在后台运行的JavaScript线程，它独立于其他脚本，不会影响页面的性能。Worker线程主要用于处理那些计算密集型或高延迟的任务，从而避免阻塞主线程，保证Web应用的流畅运行。

以下是关于Worker线程的一些关键特点和使用场景：

1. **基本概念**：Worker线程是一种独立运行的进程或线程，可以与主程序并行工作，执行一些耗时较长或需要大量计算资源的任务。通过将这些任务分配给不同的Worker线程，可以实现并发处理，从而提高程序运行效率。
2. **类型**：

- **专用工作线程（Dedicated Worker）**：与创建它的脚本连接在一起，它可以与其他的worker或是浏览器组件通信，但不能与DOM通信。
- **共享工作线程（Shared Worker）**：可以在多个浏览器窗口或者标签页之间共享。

1. **工作原理**：Web Worker是通过创建一个独立的后台线程来工作的。在主线程中可以创建和管理Web Worker，并向其发送消息。Worker线程接收消息并执行相应的任务，然后将结果返回给主线程。这样可以避免在主线程中执行耗时的任务，提高页面的性能和响应速度。
2. **适用场景**：适用于需要进行大量计算、数据处理或其他耗时任务的情况，例如数据分析、图像处理、加密解密等。
3. **注意事项**：由于Worker线程是运行在后台的，它们不能直接访问DOM，也不能访问全局变量或函数。它们只能通过消息传递与主线程进行通信。

总的来说，Worker线程是一种强大的工具，可以帮助开发者在Web应用中实现高效的并发处理，提升用户体验。



#### Worker 线程有两种你知道吗？

**是的，Worker线程主要有两种：专用工作线程（Dedicated Web Worker）和共享工作线程（Shared Web Worker）**。

1. **专用工作线程（Dedicated Web Worker）**：这是最简单的Web Worker线程。网页中的脚本可以创建专用工作线程来执行在“页面线程之外”的其他任务。这些任务可以是计算密集型的，也可以是I/O密集型的，比如网络请求或文件读写。由于专用工作线程和主线程是完全独立的，它们之间的通信需要通过消息传递来实现。
2. **共享工作线程（Shared Web Worker）**：共享工作线程允许多个脚本共享同一个工作线程。这对于需要在多个脚本之间共享数据或状态的场景非常有用。与专用工作线程不同，共享工作线程的生命周期由所有使用它的脚本共同控制。

在Web Worker线程中，直接运行JavaScript代码，但是不能操作DOM节点，也不能使用window对象的默认方法和属性、不能使用webSockets, IndexedDB等数据存储机制。主线程或Worker线程中，可以通过postMessage方法向另一个线程发送消息，使用onmessage事件函数来接收另一个线程发送的消息。



#### 

### 浏览器底层基础

#### 变量提升：javascript 代码是按顺序执行的吗

> - JavaScript 代码在执行之前需要先编译，在编译阶段，变量和函数会被存放到变量环境中，变量默认值会被设置为 undefined；
> - 在代码执行阶段，JavaScript 引擎会从变量环境中查找自定义的变量和函数；
> - 如果在编译阶段，窜爱两个相同的函数，那么最终放在变量环境中的是最后定义的那个，后定义的覆盖先定义的；



#### 调用栈：为什么 JavaScript 代码会出现栈溢出

> - 每调用一个函数，JavaScript 引擎会为其创建执行上下文压入调用栈，然后，JavaScript 引擎开始执行函数代码。
> - 如果一个函数 A 调用另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
> - 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
> - 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。



#### 块级作用域：var 缺陷以及为什么要引入 let 和 const

> - let、const 申明的变量不会被提升。在 javascript 引擎编译后，会保存在词法环境中。
> - 块级作用域在代码执行时，将 let、const 变量存放在词法环境的一个单独的区域。词法环境内部维护一个小型的栈结构，作用域内部变量压入栈顶。作用域执行完，从栈顶弹出。



#### 作用域链和闭包：代码中出现相同的变量，JavaScript 引擎如何选择

> - 使用一个变量，JavaScript 引擎会在当前的执行上下文中查找变量，如果没有找到，会继续在 outer（执行环境指向外部执行上下文的引用）所指向的执行上下文中查找；
> - JavaScript 执行过程，作用域链是由词法作用域决定，而词法作用域是由代码中函数声明的位置决定；
> - 根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使外部函数已经执行结束了，但是内部函数引用外部函数的变量依旧保存在内存中，把这些变量的集合称为闭包；



#### this：从 JavaScript 执行上下文视角讲 this

> 当执行 new CreateObj 的时候，JavaScript 引擎做了四件事：
>
> - 首先创建一个控对象 tempObj；
> - 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 createObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；
> - 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向 tempObj 对象；
> - 最后返回 tempObj 对象。
>
> this 的使用分为：
>
> - 当函数最为对象的方法调用时，函数中的 this 就是该对象；
> - 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
> - 嵌套函数中的 this 不会继承外层函数的 this 值；
> - 箭头函数没有自己的执行上下文，this 是外层函数的 this。



#### DOM 树：JavaScript 是如何影响 DOM 树构建的

> - HTML 解析器（HTMLParse）负责将 HTML 字节流转换为 DOM 结构；
> - HTML 解析器并不是等整个文档加载完成之后再解析，而是网络进程加载流多少数据，便解析多少数据；
> - 字节流转换成 DOM 三个阶段：1、字节流转换为 Token；2、维护一个 Token 栈，遇到 StartTag Token 入栈，遇到 EndTag Token 出栈；3、为每个 Token 创建一个 DOM 节点；
> - JavaScript 文件和 CSS 样式表文件都会阻塞 DOM 解析；



#### 宏任务和微任务：不是所有的任务都是一个待遇

> - 消息队列中的任务为宏任务。渲染进程内部会维护多个消息队列，比如延时执行队列和普通消息队列，主线程采用 for 循环，不断地从这些任务队列中取出任务并执行；
> - 微任务是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前；
> - V8 在执行 javascript 脚本时，会为其创建一个全局执行上下文，同时会创建一个微任务队列；
> - 执行微任务过程中产生的微任务不会推迟到下个宏任务中执行，而是在当前宏任务中继续执行；



#### 使用 Promise 告别回调函数

- 使用 Promise 解决了回调地狱问题，消灭嵌套和多次处理；
- 模拟实现 Promise

```js
function Bromise(executor) {
  var _onResolve = null
  this.then = function (onResolve) {
    _onResolve = onResolve
  }
  function resolve(value) {
    setTimeout(() => {
      _onResolve(value)
    }, 0)
  }
  executor(resolve, null)
}
```



#### async await 使用同步方式写异步代码

> - 生成器函数是一个带星号函数，而且是可以暂停执行和回复执行的；
> - 生成器函数内部执行一段代码，遇到 yield 关键字，javascript 引擎返回关键字后面的内容给外部，并且暂停该函数的执行；
> - 外部函数可以同步 next 方法恢复函数的执行；
> - 协程是一种比线程更加轻量级的存在，协程可以看成是跑在线程上的任务，一个线程可以存在多个协程，但是同时只能执行一个协程，如果 A 协程启动 B 协程，A 为 B 的父协程；
> - 协程不被操作协同内核所管理，而完全由程序所控制，这样性能提升；
> - `await xxx` 会创建一个 Promise 对象，将 `xxx` 任务提交给微任务队列；
> - 暂停当前协程的执行，将主线程的控制权力转交给父协程执行，同时将 Promise 对象返回给父协程，继续执行父协程；
> - 父协程执行结束之前会检查微任务队列，微任务队列中有 `resolve(xxx)` 等待执行，触发 then 的回调函数；
> - 回调函数被激活后，会将主线程的控制权交给协程，继续执行后续语句，完成后将控制权还给父协程。



#### webapi：setTimeout 是怎么实现的

> - JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程会创建一个回调任务，延时执行队列存放定时器任务；
> - 当定时器任务到期，就会从延时队列中取出并执行；
> - 如果当前任务执行时间过久，会影响延时到期定时器任务的执行；
> - 如果 setTimeout 存在嵌套调用（5 次以上），判断该函数方法被阻塞，那么系统会设置最短时间间隔为 4 秒；
> - 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，目的是为了降低加载损耗；
> - 延时执行时间最大值是 24.8 天，因为延时值是以 32 个 bit 存储的；
> - setTimeout 设置的回调函数中的 this 指向全局 window。



#### webapi：XMLHttpRequest 是怎么实现的

> - XMLHttpRequest onreadystatechange 处理流程：未初始化 -> OPENED -> HEADERS_RECEIVED -> LOADING -> DONE；
> - 渲染进程会将请求发送给网络进程，然后网络进程负责资源下载，等网络进程接收到数据后，利用 IPC 通知渲染进程；
> - 渲染进程接收到消息之后，会将 xhr 回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，会根据相关状态来调用回调函数。



### 浏览器运行机制



#### 栈空间和堆空间：数据是如何存储的

> 动态语言：在使用时需要检查数据类型的语言。
> 弱类型语言：支持隐式转换的语言。
>
> JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。
> 原始类型数据存放在栈中，引用类型数据存放在堆中。堆中的数据是通过引用与变量关系联系起来的。
>
> 从内存视角了解闭包：词法扫描内部函数，引用了外部函数变量，堆空间创建一个“closure”对象，保存变量。



#### 什么是浏览器的垃圾回收机制？垃圾回收的方式有哪些？



浏览器的垃圾回收机制是指浏览器通过自动回收不再使用的内存来管理内存的一种机制。在浏览器中，JavaScript程序在运行过程中会动态地分配内存，但当这些内存不再被使用时，如果没有适当的回收机制，可能会导致内存泄漏，进而影响浏览器的性能和稳定性。

浏览器的垃圾回收机制主要基于以下两种回收方式：

1. 标记清除（Mark-and-Sweep）：

- 标记阶段：垃圾回收器从根对象（如全局变量、当前正在执行的函数等）开始遍历内存中的所有对象，标记所有仍然被使用的对象。对于无法访问到的对象，垃圾回收器会将其标记为不可达对象。
- 清除阶段：垃圾回收器会清除所有被标记为不可达对象的内存空间，将其回收，以便后续的内存分配。

这种方式在现代浏览器中得到了广泛应用，如IE9+、Firefox、Opera、Chrome、Safari等浏览器的JavaScript实现都使用了标记清除的垃圾回收策略或类似的策略。

1. 引用计数（Reference Counting）：

- 原理：通过记录每个对象被引用的次数来判断对象是否可回收。当一个对象被创建时，它的引用计数为1；当它被其他对象引用时，引用计数加1；当它被其他对象释放时，引用计数减1；当它的引用计数为0时，它就可以被回收。
- 缺点：无法处理循环引用的情况，即两个或多个对象相互引用，但没有被其他对象引用，这样它们的引用计数永远不会为0，导致内存泄漏。

需要注意的是，虽然引用计数是一种较早的垃圾回收方法，但在现代浏览器中并不常用，主要是因为其无法处理循环引用的问题。

此外，浏览器的垃圾回收机制还涉及到数据的存储方式，即栈内存和堆内存。栈内存用于存储原始类型的数据，而堆内存则用于存储引用类型的值。因此，浏览器的垃圾回收机制也分为栈垃圾回收和堆垃圾回收。栈垃圾回收主要发生在函数执行结束后，通过向下移动ESP指针（记录调用栈当前执行状态的指针）来销毁函数保存在栈中的执行上下文。而堆垃圾回收则需要垃圾回收器来回收堆空间中的垃圾数据。



#### 垃圾回收：垃圾数据如何自动回收

> - 栈中数据回收：执行状态指针 ESP 在执行栈中移动，移过某执行上下文，就会被销毁；
> - 堆中数据回收：V8 引擎采用标记-清除算法；
> - V8 把堆分为两个区域——新生代和老生代，分别使用副、主垃圾回收器；
> - 副垃圾回收器负责新生代垃圾回收，小对象（1 ～ 8M）会被分配到该区域处理；
> - 新生代采用 scavenge 算法处理：将新生代空间分为两半，一半空闲，一半存对象，对对象区域做标记，存活对象复制排列到空闲区域，没有内存碎片，完成后，清理对象区域，角色反转；
> - 新生代区域两次垃圾回收还存活的对象晋升至老生代区域；
> - 主垃圾回收器负责老生区垃圾回收，大对象，存活时间长；
> - 新生代区域采用标记-清除算法回收垃圾：从根元素开始，递归，可到达的元素活动元素，否则是垃圾数据；
> - 为了不造成卡顿，标记过程被切分为一个个子标记，交替进行。

#### 【马上消费】如何最快的执行垃圾回收机制？

在JavaScript中，垃圾回收机制是由浏览器或JavaScript引擎自动管理的，因此你不能直接“执行”垃圾回收机制。但是，你可以通过一些编程实践来优化内存使用，从而间接地提高垃圾回收的效率。

以下是一些建议，可以帮助你优化JavaScript的内存使用，从而加快垃圾回收的过程：

> 1. **避免全局变量的使用**：全局变量在整个程序的生命周期内都存在，因此它们会占用更多的内存。尽量使用局部变量，并在不再需要时将其设为`null`，以便垃圾回收器可以回收它们占用的内存。
> 2. **手动解除引用**：当你不再需要某个对象时，确保将其所有引用都设为`null`。这可以帮助垃圾回收器更快地识别并回收该对象占用的内存。
> 3. **避免不必要的对象创建**：尽量减少不必要的对象创建，以减少内存分配和垃圾回收的开销。你可以使用对象池、缓存或其他技术来重用对象。
> 4. **使用适当的数据结构和算法**：选择适当的数据结构和算法可以显著减少内存使用。例如，使用数组而不是对象来存储一组有序的元素，使用哈希表来存储键值对等。
> 5. **优化循环和递归**：循环和递归是常见的内存消耗源。确保你的循环和递归逻辑是高效的，并避免在循环中创建大量对象。
> 6. **使用内存分析工具**：使用内存分析工具（如Chrome DevTools的内存面板）来检查你的程序的内存使用情况。这些工具可以帮助你找到内存泄漏和不必要的内存使用，并为你提供优化建议。

请注意，虽然这些建议可以帮助你优化JavaScript的内存使用，但垃圾回收机制仍然是由浏览器或JavaScript引擎自动管理的。因此，你不应该尝试直接控制或执行垃圾回收机制。相反，你应该专注于编写高效、内存友好的代码，并让垃圾回收器自动管理内存回收的过程。



#### 如何减少垃圾回收?

减少垃圾回收是提高程序性能和内存管理效率的关键。以下是一些减少垃圾回收的策略和技巧：

> 1. 优化数据结构
>    - 选择合适的数据结构来存储数据，避免不必要的数据复制和内存分配。
>    - 使用对象池或缓存来重用对象，而不是频繁地创建和销毁它们。
> 2. 减少不必要的对象创建
>    - 避免在循环中创建对象，尽量在循环外部创建对象，并在循环内部重复使用。
>    - 使用字符串连接操作符（如 `+`）时要小心，因为它可能导致大量的临时字符串被创建。考虑使用 `StringBuilder` 或其他类似的方法来构建字符串。
> 3. 及时解除对象引用
>    - 一旦对象不再需要，确保将其引用设为 `null` 或从集合中移除。这有助于垃圾回收器更快地识别并回收不再使用的对象。
>    - 避免长时间持有不必要的对象引用，这可能导致内存泄漏。
> 4. 使用 `WeakMap` 和 `WeakSet`
>    - 在JavaScript中，`WeakMap` 和 `WeakSet` 是两种特殊的集合类型，它们允许对象作为键或成员，但对这些对象的引用是“弱”的，这意味着它们不会阻止垃圾回收。当这些对象没有其他引用时，它们可以被垃圾回收器回收。
> 5. 避免全局变量
>    - 全局变量在整个程序的生命周期内都存在，因此它们会占用更多的内存。尽量使用局部变量，并在不再需要时将其设为 `null`。
> 6. 内存管理库和工具
>    - 使用内存管理库或工具来帮助你跟踪和管理内存使用情况。这些工具可以帮助你识别内存泄漏和不必要的内存占用。
> 7. 使用合适的垃圾回收算法
>    - 如果你正在开发一个需要高性能内存管理的应用程序，考虑使用一种具有更好垃圾回收性能的编程语言或框架。不同的语言和框架使用不同的垃圾回收算法，有些算法可能更适合你的应用程序。
> 8. 代码审查和测试
>    - 定期进行代码审查和测试，以确保你的代码没有内存泄漏或其他内存管理问题。使用自动化测试工具可以帮助你更轻松地识别和修复这些问题。
> 9. 关注内存泄漏
>    - 内存泄漏是减少垃圾回收的一个重要问题。了解常见的内存泄漏场景（如闭包、事件监听器等），并学会如何避免它们。
> 10. 更新和升级
>     - 保持你的浏览器、JavaScript引擎和库更新到最新版本。新版本可能包含性能改进和内存管理优化，这可以帮助减少垃圾回收的开销。



#### 编译器和解析器：V8 如何执行一段 JavaScript 代码的

> - 计算机语言可以分为两种：编译型和解释型语言。编译型语言经过编译器编译后保留机器能读懂的二进制文件，比如 C/C++，go 语言。解释型语言是在程序运行时通过解释器对程序进行动态解释和执行，比如 Python，JavaScript 语言。
> - 编译型语言的编译过程：编译器首先将代码进行词法分析、语法分析，生成抽象语法树（AST），然后优化代码，最后生成处理器能够理解的机器码；
> - 解释型语言解释过程：解释器会对代码进行词法分析、语法分析，并生产抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后根据字节码执行程序；
> - AST 的生成：第一阶段是分词（词法分析），将一行行源码拆解成一个个 token（语法上不可再分、最小单个字符）。第二阶段是解析（语法分析），将上一步生成的 token 数据，根据语法规则转为 AST，这一阶段会检查语法错误；
> - 字节码存在的意义：直接将 AST 转化为机器码，执行效率是非常高，但是消耗大量内存，从而先转化为字节码解决内存问题；
> - 解释器 ignition 在解释执行字节码，同时会手机代码信息，发现某一部分代码是热点代码（HotSpot），编译器把热点的字节码转化为机器码，并保存起来，下次使用；
> - 字节码配合解释器和编译器的计数实现称为即时编译（JIT）。



#### v8垃圾回收处理机制

V8是Google开源的JavaScript和WebAssembly引擎，用C++编写，主要用于Chrome和Node.js等。关于V8的垃圾回收处理机制，以下是一些关键信息：

> 1. **内存管理**：JavaScript使用自动内存管理，这被称为“垃圾回收机制”（garbage collector）。V8的内存管理是基于这个原理的，它会自动跟踪哪些对象仍在使用，哪些对象可以被回收。
> 2. **内存限制**：在64位操作系统上，V8可以使用大约1.4G的内存；在32位操作系统上，它可以使用大约0.7G的内存。
> 3. **堆（Heap）**：在V8中，堆是用于动态存放对象的内存空间。当需要存放对象时，所需的内存空间会从堆中被分配给应用程序（mutator）。一旦堆被对象占满，垃圾回收器（GC）就会启动，从而分配可用空间。
> 4. **可达性（Reachability）**：在V8中，“可达”是指那些以某种方式可访问或可用的值。这些值一定是存储在内存中的。垃圾回收器会标记所有可达的对象，并回收那些不可达的对象。
> 5. **Mutator**：Mutator是用于更改GC对象间引用关系的实体，即“应用程序”。它会生成新的对象或更新指针，这些操作会改变对象间的引用关系。在mutator执行过程中，垃圾可能会产生，而GC就是负责回收这些垃圾的机制。
> 6. **优化策略**：V8的垃圾回收器采用了多种优化策略来提高性能，例如分代回收（generational garbage collection）和增量回收（incremental garbage collection）等。

请注意，以上信息仅概述了V8垃圾回收处理机制的基本原理和关键概念。具体的实现细节和算法可能会因V8的版本和具体应用场景而有所不同。如果你对V8的垃圾回收处理机制有更深入的兴趣，建议查阅相关的技术文档或研究论文。



#### v8引擎的垃圾回收算法讲一下

V8引擎的垃圾回收算法主要基于分代式垃圾回收（Generational Garbage Collection）机制，它将内存中的对象分为不同的代（Generation），并为每一代采用不同的垃圾回收策略。以下是V8引擎中主要的垃圾回收算法：

> 1. 新生代（Young Generation）
>    - **Scavenge算法（也称为Cheney算法）**：新生代中的对象主要通过Scavenge算法进行垃圾回收。Scavenge算法是一种复制式的垃圾回收算法，它将新生代堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中（称为From空间），另一个处于闲置状态（称为To空间）。当分配对象时，先在From空间进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，并将这些存活对象复制到To空间中，同时释放非存活对象占用的空间。完成复制后，From空间和To空间的角色发生对换，称为翻转。
>    - **对象晋升（Promotion）**：新生代中的对象在经历一次或多次垃圾回收后仍然存活，它们会被移动到老生代中，采用更适合老生代的垃圾回收算法进行管理。
> 2. 老生代（Old Generation）
>    - **标记清除（Mark-Sweep）**：对于老生代中的对象，V8采用了标记清除算法进行垃圾回收。该算法分为标记和清除两个阶段。在标记阶段，垃圾回收器会从根对象开始遍历所有可达的对象，并将它们标记为活动对象。在清除阶段，垃圾回收器会释放所有未被标记为活动对象的内存空间。
>    - **标记压缩（Mark-Compact）**：为了解决内存碎片问题，V8还采用了标记压缩算法。在标记压缩算法中，除了标记阶段外，还增加了一个压缩阶段。在压缩阶段，垃圾回收器会将所有活动对象移动到内存的一端，从而消除内存碎片，提高内存利用率。
> 3. **增量标记（Incremental Marking）**：为了减少主线程停顿时间，V8还引入了增量标记算法。该算法允许垃圾回收器在主线程执行JavaScript代码的同时进行标记工作。通过将标记任务拆分成多个小任务，并在主线程空闲时执行这些任务，增量标记算法可以显著减少主线程的停顿时间。

需要注意的是，V8引擎的垃圾回收算法是一个复杂的系统，它还包括许多其他的优化技术和策略，如内存优化、并发回收等。这些技术和策略共同协作，以确保V8引擎能够高效地管理内存并提供出色的性能。



#### 消息队列和事件循环：页面是怎么活起来的

> - 每个渲染进程都有一个主线程，主线程会处理 DOM，计算样式，处理布局，JavaScript 任务以及各种输入事件；
> - 维护一个消息队列，新任务（比如 IO 线程）添加到消息队列尾部，主线程循环地从消息队列头部读取任务，执行任务；
> - 解决处理优先级高的任务：消息队列的中的任务称为宏任务，每个宏任务中都会包含一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，将该变化添加到微任务队列中；
> - 解决单个任务执行时长过久：JavaScript 通过回调功能来规避。







#### 分层和合成机制：为什么 CSS 动画比 JavaScript 高效

> - 显示器固定刷新频率是 60HZ，即每秒更新 60 张图片，图片来自显卡的前缓冲区；
> - 显卡的职责是合成新的图像，保存在后缓冲区，然后后缓冲区和前缓冲区互换，显卡更新频率和显示前刷新频率不一致，就会造成视觉上的卡顿；
> - 渲染流水线生成的每一副图片称为一帧，生成一帧的方式有重排、重绘和合成三种；
> - 重排会根据 CSSOM 和 DOM 计算布局树，重绘没有重新布局阶段；
> - 生成布局树之后，渲染引擎根据布局树特点转化为层树，每一层解析出绘制列表；
> - 栅格线程根据绘制列表中的指令生成图片，每一层对应一张图片，合成线程将这些图片合成一张图片，发送到后缓存区；
> - 合成线程会将每个图层分割成大小固定的图块，优先绘制靠近视口的图块；



### 浏览器性能优化

#### 页面性能：如何系统优化页面

> - 加载阶段：减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数；
> - 交互阶段：减少 JavaScript 脚本执行时间，避免强制同步布局：操作 DOM 的同时获取布局样式会引发，避免布局抖动：多次执行强制布局和抖动，合理利用 CSS 合成动画：标记 will-change，避免频繁的垃圾回收；
> - CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程中执行，这个过程称为合成，它不会触发重排或者重绘；



#### 虚拟 DOM：虚拟 DOM 和真实 DOM 有何不同

> - 当有数据更新时， React 会生产一个新的虚拟 DOM，然会拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程找出变化的节点，然后将变化的节点应用到 DOM 上；
> - 最开始的时候，比较两个 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。通常情况，这个比较过程执行很快，不过虚拟 DOM 比较复杂时，执行比较函数可能占据主线程比较久的时间，这样会导致其他任务的等待，造成页面卡顿。React 团队重写了 reconciliation 算法，称为 Fiber reconciler，之前老的算法称为 Stack reconciler；



#### HTTP1：HTTP1 性能优化

> - HTTP/0.9 基于 TCP 协议，三次握手建立连接，发送一个 GET 请求行（没有请求头和请求体），服务器接收请求之后，读取对应 HTML 文件，数据以 ASCII 字符流返回，传输完成断开连接；
> - HTTP/1.0 增加请求头和响应头来进行协商，在发起请求时通过请求头告诉服务器它期待返回什么类型问题、什么形式压缩、什么语言以及文件编码。引入来状态吗，Cache 机制等；
> - HTTP/1.1 改进持久化连接，解决建立 TCP 连接、传输数据和断开连接带来的大量开销，支持在一个 TCP 连接上可以传输多个 HTTP 请求，目前浏览器对于一个域名同时允许建立 6 个 TCP 持久连接；
> - HTTP/1.1 引入 Chunk transfer 支持动态生成内容：服务器将数据分割成若干任意大小的数据块，每个数据块发送时附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。在 HTTP/1.1 需要在响应头中设置完整的数据大小，如 Content-Length。



#### HTTP2：如何提升网络速度

> - HTTP/1.1 主要问题：TCP 慢启动；同时开启多条 TCP 连接，会竞争固定宽带；对头阻塞问题；
> - HTTP/2 在一个域名下只使用一个 TCP 长连接和消除对头阻塞问题；
> - 多路复用的实现：HTTP/2 添加了二进制分帧层，将发送或响应数据经过二进制分帧处理，转化为一个个带有请求 ID 编号的帧，服务器或者浏览器接收到响应帧后，根据相同 ID 帧合并为一条完整信息；
> - 设置请求优先级：发送请求可以设置请求优先级，服务器可以优先处理；
> - 服务器推送：请求一个 HTML 页面，服务器可以知道引用了哪些 JavaScript 和 CSS 文件，附带一起发送给浏览器；
> - 头部压缩：对请求头和响应头进行压缩；



#### HTTP3：甩掉 TCP、TCL 包袱，构建高效网络

> - 虽然 HTTP/2 解决了应用层面的对头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议，而 TCP 最初是为了单连接而设计；
> - TCP 可以看成是计算机之间的一个虚拟管道，数据从一端发送到另一端会被拆分为一个个按照顺序排列的数据包，如果在传输过程中，有一个数据因为网络故障或者其他原因丢失，那么整个连接会处于暂停状态，只有等到该数据重新传输；
> - 由于 TCP 协议僵化，也不可能使用新的协议，HTTP/3 选择了一个折衷的方法，基于现有的 UDP 协议，实现类似 TC 片多路复用，传输可靠等功能，称为 QULC 协议；
> - QULC 实现类似 TCP 流量控制，传输可靠功能；集成 TLS 加密功能；实现多路复用功能；
>



### 浏览器相关小贴士

#### 同源策略：为什么 XMLHttpRequst 不能跨域请求

> - 协议、域名和端口号相同的 URL 是同源的；
> - 同源策略会隔离不同源的 DOM、页面数据和网络通信；
> - 页面可以引用第三方资源，不过暴露出诸如 XSS 问题，引入内容安全策略 CSP 限制；
> - 默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，引入跨域资源共享（CORS）进行跨域访问控制；



#### 跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性

> - XSS 跨站脚本，往 HTML 文件中注入恶意代码，对用户实施攻击；
> - XSS 攻击主要有存储型 XSS 攻击、反射型 XSS 攻击和 DOM 的 XSS 攻击；
> - 阻止 XSS 攻击：服务器对脚本进行过滤或转码，利用 CSP 策略，使用 HttpOnly；



#### CSRF 攻击：陌生连接不要随便点

> - CSRF 跨站请求伪造，利用用户的登录状态，通过第三方站点攻击；
> - 避免 CSRF 攻击：利用 SameSite（三种模式：Strict、Lax、None） 让浏览器禁止第三方站点发起请求携带关键 Cookie；验证请求的来源站点，请求头中的 Referer 和 Origin 属性；利用 CSRF Token；



#### 沙盒：页面和系统之间的隔离墙

> - 浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核石油网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程；
> - 浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程；
> - 站点隔离（Site Isolation）将同一站点（包含相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行；
> - 实现站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此无法攻击其他站点；



#### HTTPS：让数据传输更安全

> - 在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密；
> - 对称加密：浏览器发送加密套件列表和一个随机数 client-random，服务器会从加密套件中选取一个加密套件，然后生成一个随机数 service-random，返回给浏览器。这样浏览器和服务器都有相同 client-random 和 service-random，再用相同的方法将两者混合生成一个密钥 master secret，双方就可以进行数据加密传输了；
> - 对称加密缺点：client-random 和 service-random 的过程都是明文，黑客可以拿到协商的加密套件和双方随机数，生成密钥，数据可以被破解；
> - 非对称加密：浏览器发送加密套件列表给服务器，服务器选择一个加密套件，返回加密套件和公钥，浏览器用公钥加密数据，服务器用私钥解密；
> - 非对称加密缺点：加密效率太低，不能保证服务器发送给浏览器的数据安全，黑客可以获取公钥；
> - 对称加密结合非对称加密：浏览器发送对称加密套件列表、非对称加密列表和随机数 client-random 给服务器，服务器生成随机数 service-random，选择加密套件和公钥返回给浏览器，浏览器利用 client-random 和 service-random 计算出 pre-master，然后利用公钥给 pre-master 加密，向服务器发送加密后的数据，服务器用私钥解密出 pre-master 数据，结合 client-random 和 service-random 生成对称密钥，使用对称密钥传输加密数据；
> - 引入数字证书是为了证明“我就是我”，防止 DNS 被劫持，伪造服务器；
> - 证书的作用：一个是向浏览器证明服务器的身份，另一个是包含服务器公钥；
> - 数字签名过程：CA 使用 Hash 函数技术明文信息，得出信息摘要，然后 CA 使用私钥对信息摘要进行加密，加密后的秘文就是数字签名；
> - 验证数字签名：读取证书明文信息，使用相同 Hash 函数计算得到信息摘要 A，再利用 CA 的公钥解密得到 B，对比 A 和 B，如果一致，则确认证书合法；
